{"ast":null,"code":"import { a as set, s as status, d as delay, f as fetch } from './fetch-deps.js';\nimport { d as data, e as errors } from './errors-deps.js';\nimport { j as jsonParse, m as matchRequestUrl, a as prepareRequest, b as prepareResponse, c as getTimestamp, d as getStatusCodeColor } from './matchRequestUrl-deps.js'; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\nvar nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n\nfunction devAssert(condition, message) {\n  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n\nfunction _typeof$1(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof$1 = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof$1 = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof$1(obj);\n}\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\n\n\nfunction isObjectLike(value) {\n  return _typeof$1(value) == 'object' && value !== null;\n} // In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\n\n\nvar SYMBOL_TO_STRING_TAG = // $FlowFixMe Flow doesn't define `Symbol.toStringTag` yet\ntypeof Symbol === 'function' ? Symbol.toStringTag : '@@toStringTag';\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\n\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\n\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\n\nfunction printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var subLineIndex = Math.floor(columnNum / 80);\n    var subLineColumnNum = columnNum % 80;\n    var subLines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function (subLine) {\n      return ['', subLine];\n    }), [[' ', whitespace(subLineColumnNum - 1) + '^'], ['', subLines[subLineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction leftPad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n\nfunction _typeof$2(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof$2 = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof$2 = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof$2(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof$2(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\n\nvar GraphQLError = /*#__PURE__*/function (_Error) {\n  _inherits(GraphQLError, _Error);\n\n  var _super = _createSuper(GraphQLError);\n  /**\n   * A message describing the Error for debugging purposes.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   *\n   * Note: should be treated as readonly, despite invariant usage.\n   */\n\n  /**\n   * An array of { line, column } locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n\n  function GraphQLError(message, nodes, source, positions, path, originalError, extensions) {\n    var _locations2, _source2, _positions2, _extensions2;\n\n    var _this;\n\n    _classCallCheck(this, GraphQLError);\n\n    _this = _super.call(this, message); // Compute list of blame nodes.\n\n    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n    var _source = source;\n\n    if (!_source && _nodes) {\n      var _nodes$0$loc;\n\n      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;\n    }\n\n    var _positions = positions;\n\n    if (!_positions && _nodes) {\n      _positions = _nodes.reduce(function (list, node) {\n        if (node.loc) {\n          list.push(node.loc.start);\n        }\n\n        return list;\n      }, []);\n    }\n\n    if (_positions && _positions.length === 0) {\n      _positions = undefined;\n    }\n\n    var _locations;\n\n    if (positions && source) {\n      _locations = positions.map(function (pos) {\n        return getLocation(source, pos);\n      });\n    } else if (_nodes) {\n      _locations = _nodes.reduce(function (list, node) {\n        if (node.loc) {\n          list.push(getLocation(node.loc.source, node.loc.start));\n        }\n\n        return list;\n      }, []);\n    }\n\n    var _extensions = extensions;\n\n    if (_extensions == null && originalError != null) {\n      var originalExtensions = originalError.extensions;\n\n      if (isObjectLike(originalExtensions)) {\n        _extensions = originalExtensions;\n      }\n    }\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      name: {\n        value: 'GraphQLError'\n      },\n      message: {\n        value: message,\n        // By being enumerable, JSON.stringify will include `message` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: true,\n        writable: true\n      },\n      locations: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : undefined,\n        // By being enumerable, JSON.stringify will include `locations` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: _locations != null\n      },\n      path: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: path !== null && path !== void 0 ? path : undefined,\n        // By being enumerable, JSON.stringify will include `path` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: path != null\n      },\n      nodes: {\n        value: _nodes !== null && _nodes !== void 0 ? _nodes : undefined\n      },\n      source: {\n        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : undefined\n      },\n      positions: {\n        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : undefined\n      },\n      originalError: {\n        value: originalError\n      },\n      extensions: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : undefined,\n        // By being enumerable, JSON.stringify will include `path` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: _extensions != null\n      }\n    }); // Include (non-enumerable) stack trace.\n\n    if (originalError === null || originalError === void 0 ? void 0 : originalError.stack) {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n      return _possibleConstructorReturn(_this);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError);\n    } else {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(GraphQLError, [{\n    key: \"toString\",\n    value: function toString() {\n      return printError(this);\n    } // FIXME: workaround to not break chai comparisons, should be remove in v16\n    // $FlowFixMe Flow doesn't support computed properties yet\n\n  }, {\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Object';\n    }\n  }]);\n\n  return GraphQLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\n\nfunction printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\n\nfunction syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n/**\n * The set of allowed kind values for AST nodes.\n */\n\n\nvar Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n\nfunction invariant(condition, message) {\n  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')\n\n  if (!booleanCondition) {\n    throw new Error(message != null ? message : 'Unexpected invariant triggered.');\n  }\n}\n/**\n * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`\n */\n\n\nfunction defineInspect(classObject) {\n  var fn = classObject.prototype.toJSON;\n  typeof fn === 'function' || invariant(0);\n  classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\n\n\nvar Location = /*#__PURE__*/function () {\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The Token at which this Node begins.\n   */\n\n  /**\n   * The Token at which this Node ends.\n   */\n\n  /**\n   * The Source document the AST represents.\n   */\n  function Location(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  var _proto = Location.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  };\n\n  return Location;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\n\ndefineInspect(Location);\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\n\nvar Token = /*#__PURE__*/function () {\n  /**\n   * The kind of Token.\n   */\n\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   */\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  function Token(kind, start, end, line, column, prev, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column;\n    this.value = value;\n    this.prev = prev;\n    this.next = null;\n  }\n\n  var _proto2 = Token.prototype;\n\n  _proto2.toJSON = function toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  };\n\n  return Token;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\n\ndefineInspect(Token);\n/**\n * The list of all possible AST node types.\n */\n\nfunction _defineProperties$1(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass$1(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties$1(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\n * optional, but they are useful for clients who store GraphQL documents in source files.\n * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\n * be useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\n * The `line` and `column` properties in `locationOffset` are 1-indexed.\n */\n\n\nvar Source = /*#__PURE__*/function () {\n  function Source(body) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GraphQL request';\n    var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      line: 1,\n      column: 1\n    };\n    this.body = body;\n    this.name = name;\n    this.locationOffset = locationOffset;\n    this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive.');\n    this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive.');\n  } // $FlowFixMe Flow doesn't support computed properties yet\n\n\n  _createClass$1(Source, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Source';\n    }\n  }]);\n\n  return Source;\n}();\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\n\n\nvar TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n\n/**\n * The set of allowed directive location values.\n */\n\nvar DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\n\nvar Lexer = /*#__PURE__*/function () {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  function Lexer(source) {\n    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  var _proto = Lexer.prototype;\n\n  _proto.advance = function advance() {\n    this.lastToken = this.token;\n    var token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n  ;\n\n  _proto.lookahead = function lookahead() {\n    var token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        var _token$next; // Note: next is only mutable during parsing, so we cast to allow this.\n\n\n        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  };\n\n  return Lexer;\n}();\n/**\n * @internal\n */\n\n\nfunction isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Token(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Token(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Token(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Token(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Token(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Token(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Token(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Token(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Token(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Token(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Token(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Token(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Token(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Token(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 46 || isNameStart(code)) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n} // _ A-Z a-z\n\n\nfunction isNameStart(code) {\n  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;\n}\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\nfunction parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        var _this$_options2;\n\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3; // Legacy support for the SDL?\n\n\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n\nconst graphqlContext = {\n  set,\n  status,\n  delay,\n  fetch,\n  data,\n  errors\n};\n\nfunction parseQuery(query, definitionOperation = 'query') {\n  var _a;\n\n  const ast = parse(query);\n  const operationDef = ast.definitions.find(def => {\n    return def.kind === 'OperationDefinition' && (definitionOperation === 'all' || def.operation === definitionOperation);\n  });\n  return {\n    operationType: operationDef === null || operationDef === void 0 ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef === null || operationDef === void 0 ? void 0 : operationDef.name) === null || _a === void 0 ? void 0 : _a.value\n  };\n}\n\nfunction graphQLRequestHandler(expectedOperationType, expectedOperationName, mask, resolver) {\n  return {\n    resolver,\n\n    parse(req) {\n      var _a; // According to the GraphQL specification, a GraphQL request can be issued\n      // using both \"GET\" and \"POST\" methods.\n\n\n      switch (req.method) {\n        case 'GET':\n          {\n            const query = req.url.searchParams.get('query');\n            const variablesString = req.url.searchParams.get('variables') || '';\n\n            if (!query) {\n              return null;\n            }\n\n            const variables = variablesString ? jsonParse(variablesString) : {};\n            const {\n              operationType,\n              operationName\n            } = parseQuery(query, expectedOperationType);\n            return {\n              operationType,\n              operationName,\n              variables\n            };\n          }\n\n        case 'POST':\n          {\n            if (!((_a = req.body) === null || _a === void 0 ? void 0 : _a.query)) {\n              return null;\n            }\n\n            const {\n              query,\n              variables\n            } = req.body;\n            const {\n              operationType,\n              operationName\n            } = parseQuery(query, expectedOperationType);\n            return {\n              operationType,\n              operationName,\n              variables\n            };\n          }\n\n        default:\n          return null;\n      }\n    },\n\n    getPublicRequest(req, parsed) {\n      return Object.assign(Object.assign({}, req), {\n        variables: parsed.variables || {}\n      });\n    },\n\n    predicate(req, parsed) {\n      if (!parsed || !parsed.operationName) {\n        return false;\n      } // Match the request URL against a given mask,\n      // in case of an endpoint-specific request handler.\n\n\n      const hasMatchingMask = matchRequestUrl(req.url, mask);\n      const isMatchingOperation = expectedOperationName instanceof RegExp ? expectedOperationName.test(parsed.operationName) : expectedOperationName === parsed.operationName;\n      return hasMatchingMask.matches && isMatchingOperation;\n    },\n\n    defineContext() {\n      return graphqlContext;\n    },\n\n    log(req, res, handler, parsed) {\n      const {\n        operationType,\n        operationName\n      } = parsed;\n      const loggedRequest = prepareRequest(req);\n      const loggedResponse = prepareResponse(res);\n      console.groupCollapsed('[MSW] %s %s (%c%s%c)', getTimestamp(), operationName, `color:${getStatusCodeColor(res.status)}`, res.status, 'color:inherit');\n      console.log('Request:', loggedRequest);\n      console.log('Handler:', {\n        operationType,\n        operationName: expectedOperationName,\n        predicate: handler.predicate\n      });\n      console.log('Response:', loggedResponse);\n      console.groupEnd();\n    }\n\n  };\n}\n\nconst createGraphQLScopedHandler = (expectedOperationType, mask) => {\n  return (expectedOperationName, resolver) => {\n    return graphQLRequestHandler(expectedOperationType, expectedOperationName, mask, resolver);\n  };\n};\n\nconst createGraphQLOperationHandler = mask => {\n  return resolver => {\n    return graphQLRequestHandler('all', new RegExp('.*'), mask, resolver);\n  };\n};\n\nconst graphqlStandardHandlers = {\n  operation: createGraphQLOperationHandler('*'),\n  query: createGraphQLScopedHandler('query', '*'),\n  mutation: createGraphQLScopedHandler('mutation', '*')\n};\n\nfunction createGraphQLLink(uri) {\n  return {\n    operation: createGraphQLOperationHandler(uri),\n    query: createGraphQLScopedHandler('query', uri),\n    mutation: createGraphQLScopedHandler('mutation', uri)\n  };\n}\n\nconst graphql = Object.assign(Object.assign({}, graphqlStandardHandlers), {\n  link: createGraphQLLink\n});\nexport { graphql, graphqlContext };","map":{"version":3,"sources":["/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/msw/lib/esm/graphql.js"],"names":["a","set","s","status","d","delay","f","fetch","data","e","errors","j","jsonParse","m","matchRequestUrl","prepareRequest","b","prepareResponse","c","getTimestamp","getStatusCodeColor","nodejsCustomInspectSymbol","Symbol","for","undefined","_typeof","obj","iterator","constructor","prototype","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","inspect","value","formatValue","seenValues","JSON","stringify","name","concat","formatObjectValue","String","previouslySeenValues","indexOf","customInspectFn","getCustomFn","customValue","call","Array","isArray","formatArray","formatObject","object","keys","Object","length","getObjectTag","properties","map","key","join","array","len","Math","min","remaining","items","i","push","tag","toString","replace","devAssert","condition","message","booleanCondition","Boolean","Error","_typeof$1","isObjectLike","SYMBOL_TO_STRING_TAG","toStringTag","getLocation","source","position","lineRegexp","line","column","match","exec","body","index","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","lines","split","locationLine","subLineIndex","floor","subLineColumnNum","subLines","slice","printPrefixedLines","subLine","existingLines","filter","_ref","_","padLen","max","apply","_ref2","prefix","_ref3","leftPad","str","_typeof$2","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","_setPrototypeOf","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf","result","NewTarget","Reflect","construct","arguments","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","_wrapNativeSuper","Class","_cache","Map","_isNativeFunction","has","get","Wrapper","_construct","Parent","args","Function","bind","sham","Proxy","Date","fn","o","p","setPrototypeOf","__proto__","getPrototypeOf","GraphQLError","_Error","_super","nodes","positions","path","originalError","extensions","_locations2","_source2","_positions2","_extensions2","_this","_nodes","_source","_nodes$0$loc","loc","_positions","reduce","list","node","_locations","pos","_extensions","originalExtensions","defineProperties","locations","stack","captureStackTrace","printError","error","output","_i2","_error$nodes2","_i4","_error$locations2","syntaxError","description","Kind","freeze","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","invariant","defineInspect","classObject","toJSON","Location","startToken","endToken","end","_proto","Token","kind","prev","next","_proto2","_defineProperties$1","_createClass$1","Source","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","dedentBlockStringValue","rawString","commonIndent","getBlockStringIndentation","isBlank","shift","pop","indent","leadingWhitespace","Lexer","startOfFileToken","lastToken","token","lineStart","advance","lookahead","_token$next","readToken","isPunctuatorTokenKind","printCharCode","code","isNaN","fromCharCode","toUpperCase","lexer","bodyLength","positionAfterWhitespace","col","charCodeAt","readComment","readName","readNumber","readBlockString","readString","unexpectedCharacterMessage","startPosition","firstCode","isFloat","readDigits","isNameStart","chunkStart","charCode","uniCharCode","invalidSequence","rawValue","char2hex","parse","options","parser","Parser","parseDocument","sourceObj","_lexer","_options","parseName","expectToken","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","operation","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseValueLiteral","selections","parseSelection","parseFragment","parseField","nameOrAlias","alias","parseArguments","isConst","item","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","parseList","parseObject","parseStringLiteral","block","values","any","_this2","parseObjectField","fields","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","types","_this$_options2","allowLegacySDLImplementsInterfaces","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","_this$_options4","noLocation","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","graphqlContext","parseQuery","query","definitionOperation","_a","ast","operationDef","find","def","operationType","operationName","graphQLRequestHandler","expectedOperationType","expectedOperationName","mask","resolver","req","method","url","searchParams","variablesString","variables","getPublicRequest","parsed","assign","predicate","hasMatchingMask","isMatchingOperation","RegExp","test","matches","defineContext","log","res","handler","loggedRequest","loggedResponse","console","groupCollapsed","groupEnd","createGraphQLScopedHandler","createGraphQLOperationHandler","graphqlStandardHandlers","mutation","createGraphQLLink","uri","graphql","link"],"mappings":"AAAA,SAASA,CAAC,IAAIC,GAAd,EAAmBC,CAAC,IAAIC,MAAxB,EAAgCC,CAAC,IAAIC,KAArC,EAA4CC,CAAC,IAAIC,KAAjD,QAA8D,iBAA9D;AACA,SAASH,CAAC,IAAII,IAAd,EAAoBC,CAAC,IAAIC,MAAzB,QAAuC,kBAAvC;AACA,SAASC,CAAC,IAAIC,SAAd,EAAyBC,CAAC,IAAIC,eAA9B,EAA+Cd,CAAC,IAAIe,cAApD,EAAoEC,CAAC,IAAIC,eAAzE,EAA0FC,CAAC,IAAIC,YAA/F,EAA6Gf,CAAC,IAAIgB,kBAAlH,QAA4I,2BAA5I,C,CAEA;;AACA,IAAIC,yBAAyB,GAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,GAAd,KAAsB,UAAtD,GAAmED,MAAM,CAACC,GAAP,CAAW,4BAAX,CAAnE,GAA8GC,SAA9I;;AAEA,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AAAE;;AAA2B,MAAI,OAAOJ,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACK,QAAd,KAA2B,QAA/D,EAAyE;AAAEF,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAED,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOJ,MAAP,KAAkB,UAAzB,IAAuCI,GAAG,CAACE,WAAJ,KAAoBN,MAA3D,IAAqEI,GAAG,KAAKJ,MAAM,CAACO,SAApF,GAAgG,QAAhG,GAA2G,OAAOH,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOD,OAAO,CAACC,GAAD,CAAd;AAAsB;;AAC1X,IAAII,gBAAgB,GAAG,EAAvB;AACA,IAAIC,mBAAmB,GAAG,CAA1B;AACA;AACA;AACA;;AAEA,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,SAAOC,WAAW,CAACD,KAAD,EAAQ,EAAR,CAAlB;AACD;;AAED,SAASC,WAAT,CAAqBD,KAArB,EAA4BE,UAA5B,EAAwC;AACtC,UAAQV,OAAO,CAACQ,KAAD,CAAf;AACE,SAAK,QAAL;AACE,aAAOG,IAAI,CAACC,SAAL,CAAeJ,KAAf,CAAP;;AAEF,SAAK,UAAL;AACE,aAAOA,KAAK,CAACK,IAAN,GAAa,aAAaC,MAAb,CAAoBN,KAAK,CAACK,IAA1B,EAAgC,GAAhC,CAAb,GAAoD,YAA3D;;AAEF,SAAK,QAAL;AACE,UAAIL,KAAK,KAAK,IAAd,EAAoB;AAClB,eAAO,MAAP;AACD;;AAED,aAAOO,iBAAiB,CAACP,KAAD,EAAQE,UAAR,CAAxB;;AAEF;AACE,aAAOM,MAAM,CAACR,KAAD,CAAb;AAfJ;AAiBD;;AAED,SAASO,iBAAT,CAA2BP,KAA3B,EAAkCS,oBAAlC,EAAwD;AACtD,MAAIA,oBAAoB,CAACC,OAArB,CAA6BV,KAA7B,MAAwC,CAAC,CAA7C,EAAgD;AAC9C,WAAO,YAAP;AACD;;AAED,MAAIE,UAAU,GAAG,GAAGI,MAAH,CAAUG,oBAAV,EAAgC,CAACT,KAAD,CAAhC,CAAjB;AACA,MAAIW,eAAe,GAAGC,WAAW,CAACZ,KAAD,CAAjC;;AAEA,MAAIW,eAAe,KAAKpB,SAAxB,EAAmC;AACjC;AACA,QAAIsB,WAAW,GAAGF,eAAe,CAACG,IAAhB,CAAqBd,KAArB,CAAlB,CAFiC,CAEc;;AAE/C,QAAIa,WAAW,KAAKb,KAApB,EAA2B;AACzB,aAAO,OAAOa,WAAP,KAAuB,QAAvB,GAAkCA,WAAlC,GAAgDZ,WAAW,CAACY,WAAD,EAAcX,UAAd,CAAlE;AACD;AACF,GAPD,MAOO,IAAIa,KAAK,CAACC,OAAN,CAAchB,KAAd,CAAJ,EAA0B;AAC/B,WAAOiB,WAAW,CAACjB,KAAD,EAAQE,UAAR,CAAlB;AACD;;AAED,SAAOgB,YAAY,CAAClB,KAAD,EAAQE,UAAR,CAAnB;AACD;;AAED,SAASgB,YAAT,CAAsBC,MAAtB,EAA8BjB,UAA9B,EAA0C;AACxC,MAAIkB,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,MAAZ,CAAX;;AAEA,MAAIC,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrB,WAAO,IAAP;AACD;;AAED,MAAIpB,UAAU,CAACoB,MAAX,GAAoBxB,mBAAxB,EAA6C;AAC3C,WAAO,MAAMyB,YAAY,CAACJ,MAAD,CAAlB,GAA6B,GAApC;AACD;;AAED,MAAIK,UAAU,GAAGJ,IAAI,CAACK,GAAL,CAAS,UAAUC,GAAV,EAAe;AACvC,QAAI1B,KAAK,GAAGC,WAAW,CAACkB,MAAM,CAACO,GAAD,CAAP,EAAcxB,UAAd,CAAvB;AACA,WAAOwB,GAAG,GAAG,IAAN,GAAa1B,KAApB;AACD,GAHgB,CAAjB;AAIA,SAAO,OAAOwB,UAAU,CAACG,IAAX,CAAgB,IAAhB,CAAP,GAA+B,IAAtC;AACD;;AAED,SAASV,WAAT,CAAqBW,KAArB,EAA4B1B,UAA5B,EAAwC;AACtC,MAAI0B,KAAK,CAACN,MAAN,KAAiB,CAArB,EAAwB;AACtB,WAAO,IAAP;AACD;;AAED,MAAIpB,UAAU,CAACoB,MAAX,GAAoBxB,mBAAxB,EAA6C;AAC3C,WAAO,SAAP;AACD;;AAED,MAAI+B,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASlC,gBAAT,EAA2B+B,KAAK,CAACN,MAAjC,CAAV;AACA,MAAIU,SAAS,GAAGJ,KAAK,CAACN,MAAN,GAAeO,GAA/B;AACA,MAAII,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyB,EAAEK,CAA3B,EAA8B;AAC5BD,IAAAA,KAAK,CAACE,IAAN,CAAWlC,WAAW,CAAC2B,KAAK,CAACM,CAAD,CAAN,EAAWhC,UAAX,CAAtB;AACD;;AAED,MAAI8B,SAAS,KAAK,CAAlB,EAAqB;AACnBC,IAAAA,KAAK,CAACE,IAAN,CAAW,iBAAX;AACD,GAFD,MAEO,IAAIH,SAAS,GAAG,CAAhB,EAAmB;AACxBC,IAAAA,KAAK,CAACE,IAAN,CAAW,OAAO7B,MAAP,CAAc0B,SAAd,EAAyB,aAAzB,CAAX;AACD;;AAED,SAAO,MAAMC,KAAK,CAACN,IAAN,CAAW,IAAX,CAAN,GAAyB,GAAhC;AACD;;AAED,SAASf,WAAT,CAAqBO,MAArB,EAA6B;AAC3B,MAAIR,eAAe,GAAGQ,MAAM,CAACX,MAAM,CAACpB,yBAAD,CAAP,CAA5B;;AAEA,MAAI,OAAOuB,eAAP,KAA2B,UAA/B,EAA2C;AACzC,WAAOA,eAAP;AACD;;AAED,MAAI,OAAOQ,MAAM,CAACpB,OAAd,KAA0B,UAA9B,EAA0C;AACxC,WAAOoB,MAAM,CAACpB,OAAd;AACD;AACF;;AAED,SAASwB,YAAT,CAAsBJ,MAAtB,EAA8B;AAC5B,MAAIiB,GAAG,GAAGf,MAAM,CAACzB,SAAP,CAAiByC,QAAjB,CAA0BvB,IAA1B,CAA+BK,MAA/B,EAAuCmB,OAAvC,CAA+C,YAA/C,EAA6D,EAA7D,EAAiEA,OAAjE,CAAyE,IAAzE,EAA+E,EAA/E,CAAV;;AAEA,MAAIF,GAAG,KAAK,QAAR,IAAoB,OAAOjB,MAAM,CAACxB,WAAd,KAA8B,UAAtD,EAAkE;AAChE,QAAIU,IAAI,GAAGc,MAAM,CAACxB,WAAP,CAAmBU,IAA9B;;AAEA,QAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,EAAzC,EAA6C;AAC3C,aAAOA,IAAP;AACD;AACF;;AAED,SAAO+B,GAAP;AACD;;AAED,SAASG,SAAT,CAAmBC,SAAnB,EAA8BC,OAA9B,EAAuC;AACrC,MAAIC,gBAAgB,GAAGC,OAAO,CAACH,SAAD,CAA9B,CADqC,CACM;;AAE3C,MAAI,CAACE,gBAAL,EAAuB;AACrB,UAAM,IAAIE,KAAJ,CAAUH,OAAV,CAAN;AACD;AACF;;AAED,SAASI,SAAT,CAAmBpD,GAAnB,EAAwB;AAAE;;AAA2B,MAAI,OAAOJ,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACK,QAAd,KAA2B,QAA/D,EAAyE;AAAEmD,IAAAA,SAAS,GAAG,SAASrD,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAxD;AAA2D,GAAtI,MAA4I;AAAEoD,IAAAA,SAAS,GAAG,SAASrD,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOJ,MAAP,KAAkB,UAAzB,IAAuCI,GAAG,CAACE,WAAJ,KAAoBN,MAA3D,IAAqEI,GAAG,KAAKJ,MAAM,CAACO,SAApF,GAAgG,QAAhG,GAA2G,OAAOH,GAAzH;AAA+H,KAAnK;AAAsK;;AAAC,SAAOoD,SAAS,CAACpD,GAAD,CAAhB;AAAwB;AAElY;AACA;AACA;AACA;;;AACA,SAASqD,YAAT,CAAsB9C,KAAtB,EAA6B;AAC3B,SAAO6C,SAAS,CAAC7C,KAAD,CAAT,IAAoB,QAApB,IAAgCA,KAAK,KAAK,IAAjD;AACD,C,CAED;;;AAEA,IAAI+C,oBAAoB,GAAG;AAC3B,OAAO1D,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAAC2D,WAAtC,GAAoD,eADpD;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuC;AACrC,MAAIC,UAAU,GAAG,cAAjB;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,MAAM,GAAGH,QAAQ,GAAG,CAAxB;AACA,MAAII,KAAJ;;AAEA,SAAO,CAACA,KAAK,GAAGH,UAAU,CAACI,IAAX,CAAgBN,MAAM,CAACO,IAAvB,CAAT,KAA0CF,KAAK,CAACG,KAAN,GAAcP,QAA/D,EAAyE;AACvEE,IAAAA,IAAI,IAAI,CAAR;AACAC,IAAAA,MAAM,GAAGH,QAAQ,GAAG,CAAX,IAAgBI,KAAK,CAACG,KAAN,GAAcH,KAAK,CAAC,CAAD,CAAL,CAASjC,MAAvC,CAAT;AACD;;AAED,SAAO;AACL+B,IAAAA,IAAI,EAAEA,IADD;AAELC,IAAAA,MAAM,EAAEA;AAFH,GAAP;AAID;AAED;AACA;AACA;;;AAEA,SAASK,aAAT,CAAuBC,QAAvB,EAAiC;AAC/B,SAAOC,mBAAmB,CAACD,QAAQ,CAACV,MAAV,EAAkBD,WAAW,CAACW,QAAQ,CAACV,MAAV,EAAkBU,QAAQ,CAACE,KAA3B,CAA7B,CAA1B;AACD;AACD;AACA;AACA;;;AAEA,SAASD,mBAAT,CAA6BX,MAA7B,EAAqCa,cAArC,EAAqD;AACnD,MAAIC,qBAAqB,GAAGd,MAAM,CAACe,cAAP,CAAsBX,MAAtB,GAA+B,CAA3D;AACA,MAAIG,IAAI,GAAGS,UAAU,CAACF,qBAAD,CAAV,GAAoCd,MAAM,CAACO,IAAtD;AACA,MAAIU,SAAS,GAAGJ,cAAc,CAACV,IAAf,GAAsB,CAAtC;AACA,MAAIe,UAAU,GAAGlB,MAAM,CAACe,cAAP,CAAsBZ,IAAtB,GAA6B,CAA9C;AACA,MAAIgB,OAAO,GAAGN,cAAc,CAACV,IAAf,GAAsBe,UAApC;AACA,MAAIE,YAAY,GAAGP,cAAc,CAACV,IAAf,KAAwB,CAAxB,GAA4BW,qBAA5B,GAAoD,CAAvE;AACA,MAAIO,SAAS,GAAGR,cAAc,CAACT,MAAf,GAAwBgB,YAAxC;AACA,MAAIE,WAAW,GAAG,GAAGlE,MAAH,CAAU4C,MAAM,CAAC7C,IAAjB,EAAuB,GAAvB,EAA4BC,MAA5B,CAAmC+D,OAAnC,EAA4C,GAA5C,EAAiD/D,MAAjD,CAAwDiE,SAAxD,EAAmE,IAAnE,CAAlB;AACA,MAAIE,KAAK,GAAGhB,IAAI,CAACiB,KAAL,CAAW,cAAX,CAAZ;AACA,MAAIC,YAAY,GAAGF,KAAK,CAACN,SAAD,CAAxB,CAVmD,CAUd;;AAErC,MAAIQ,YAAY,CAACrD,MAAb,GAAsB,GAA1B,EAA+B;AAC7B,QAAIsD,YAAY,GAAG9C,IAAI,CAAC+C,KAAL,CAAWN,SAAS,GAAG,EAAvB,CAAnB;AACA,QAAIO,gBAAgB,GAAGP,SAAS,GAAG,EAAnC;AACA,QAAIQ,QAAQ,GAAG,EAAf;;AAEA,SAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,YAAY,CAACrD,MAAjC,EAAyCY,CAAC,IAAI,EAA9C,EAAkD;AAChD6C,MAAAA,QAAQ,CAAC5C,IAAT,CAAcwC,YAAY,CAACK,KAAb,CAAmB9C,CAAnB,EAAsBA,CAAC,GAAG,EAA1B,CAAd;AACD;;AAED,WAAOsC,WAAW,GAAGS,kBAAkB,CAAC,CAAC,CAAC,GAAG3E,MAAH,CAAU+D,OAAV,CAAD,EAAqBU,QAAQ,CAAC,CAAD,CAA7B,CAAD,EAAoCzE,MAApC,CAA2CyE,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkBJ,YAAY,GAAG,CAAjC,EAAoCnD,GAApC,CAAwC,UAAUyD,OAAV,EAAmB;AAC5I,aAAO,CAAC,EAAD,EAAKA,OAAL,CAAP;AACD,KAFkF,CAA3C,EAEpC,CAAC,CAAC,GAAD,EAAMhB,UAAU,CAACY,gBAAgB,GAAG,CAApB,CAAV,GAAmC,GAAzC,CAAD,EAAgD,CAAC,EAAD,EAAKC,QAAQ,CAACH,YAAY,GAAG,CAAhB,CAAb,CAAhD,CAFoC,CAAD,CAAvC;AAGD;;AAED,SAAOJ,WAAW,GAAGS,kBAAkB,CAAC,CAAC;AACzC,GAAC,GAAG3E,MAAH,CAAU+D,OAAO,GAAG,CAApB,CAAD,EAAyBI,KAAK,CAACN,SAAS,GAAG,CAAb,CAA9B,CADwC,EACQ,CAAC,GAAG7D,MAAH,CAAU+D,OAAV,CAAD,EAAqBM,YAArB,CADR,EAC4C,CAAC,EAAD,EAAKT,UAAU,CAACK,SAAS,GAAG,CAAb,CAAV,GAA4B,GAAjC,CAD5C,EACmF,CAAC,GAAGjE,MAAH,CAAU+D,OAAO,GAAG,CAApB,CAAD,EAAyBI,KAAK,CAACN,SAAS,GAAG,CAAb,CAA9B,CADnF,CAAD,CAAvC;AAED;;AAED,SAASc,kBAAT,CAA4BR,KAA5B,EAAmC;AACjC,MAAIU,aAAa,GAAGV,KAAK,CAACW,MAAN,CAAa,UAAUC,IAAV,EAAgB;AAC/C,QAAIC,CAAC,GAAGD,IAAI,CAAC,CAAD,CAAZ;AAAA,QACIhC,IAAI,GAAGgC,IAAI,CAAC,CAAD,CADf;AAEA,WAAOhC,IAAI,KAAK9D,SAAhB;AACD,GAJmB,CAApB;AAKA,MAAIgG,MAAM,GAAGzD,IAAI,CAAC0D,GAAL,CAASC,KAAT,CAAe3D,IAAf,EAAqBqD,aAAa,CAAC1D,GAAd,CAAkB,UAAUiE,KAAV,EAAiB;AACnE,QAAIC,MAAM,GAAGD,KAAK,CAAC,CAAD,CAAlB;AACA,WAAOC,MAAM,CAACrE,MAAd;AACD,GAHiC,CAArB,CAAb;AAIA,SAAO6D,aAAa,CAAC1D,GAAd,CAAkB,UAAUmE,KAAV,EAAiB;AACxC,QAAID,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAlB;AAAA,QACIvC,IAAI,GAAGuC,KAAK,CAAC,CAAD,CADhB;AAEA,WAAOC,OAAO,CAACN,MAAD,EAASI,MAAT,CAAP,IAA2BtC,IAAI,GAAG,QAAQA,IAAX,GAAkB,IAAjD,CAAP;AACD,GAJM,EAIJ1B,IAJI,CAIC,IAJD,CAAP;AAKD;;AAED,SAASuC,UAAT,CAAoBrC,GAApB,EAAyB;AACvB,SAAOd,KAAK,CAACc,GAAG,GAAG,CAAP,CAAL,CAAeF,IAAf,CAAoB,GAApB,CAAP;AACD;;AAED,SAASkE,OAAT,CAAiBhE,GAAjB,EAAsBiE,GAAtB,EAA2B;AACzB,SAAO5B,UAAU,CAACrC,GAAG,GAAGiE,GAAG,CAACxE,MAAX,CAAV,GAA+BwE,GAAtC;AACD;;AAED,SAASC,SAAT,CAAmBtG,GAAnB,EAAwB;AAAE;;AAA2B,MAAI,OAAOJ,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACK,QAAd,KAA2B,QAA/D,EAAyE;AAAEqG,IAAAA,SAAS,GAAG,SAASvG,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAxD;AAA2D,GAAtI,MAA4I;AAAEsG,IAAAA,SAAS,GAAG,SAASvG,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOJ,MAAP,KAAkB,UAAzB,IAAuCI,GAAG,CAACE,WAAJ,KAAoBN,MAA3D,IAAqEI,GAAG,KAAKJ,MAAM,CAACO,SAApF,GAAgG,QAAhG,GAA2G,OAAOH,GAAzH;AAA+H,KAAnK;AAAsK;;AAAC,SAAOsG,SAAS,CAACtG,GAAD,CAAhB;AAAwB;;AAElY,SAASuG,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoE,KAAK,CAAChF,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AAAE,QAAIqE,UAAU,GAAGD,KAAK,CAACpE,CAAD,CAAtB;AAA2BqE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BrF,IAAAA,MAAM,CAACsF,cAAP,CAAsBN,MAAtB,EAA8BE,UAAU,CAAC7E,GAAzC,EAA8C6E,UAA9C;AAA4D;AAAE;;AAE7T,SAASK,YAAT,CAAsBV,WAAtB,EAAmCW,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBT,iBAAiB,CAACF,WAAW,CAACtG,SAAb,EAAwBiH,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBV,iBAAiB,CAACF,WAAD,EAAcY,WAAd,CAAjB;AAA6C,SAAOZ,WAAP;AAAqB;;AAEvN,SAASa,SAAT,CAAmBC,QAAnB,EAA6BC,UAA7B,EAAyC;AAAE,MAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAAE,UAAM,IAAId,SAAJ,CAAc,oDAAd,CAAN;AAA4E;;AAACa,EAAAA,QAAQ,CAACpH,SAAT,GAAqByB,MAAM,CAAC6F,MAAP,CAAcD,UAAU,IAAIA,UAAU,CAACrH,SAAvC,EAAkD;AAAED,IAAAA,WAAW,EAAE;AAAEK,MAAAA,KAAK,EAAEgH,QAAT;AAAmBN,MAAAA,QAAQ,EAAE,IAA7B;AAAmCD,MAAAA,YAAY,EAAE;AAAjD;AAAf,GAAlD,CAArB;AAAkJ,MAAIQ,UAAJ,EAAgBE,eAAe,CAACH,QAAD,EAAWC,UAAX,CAAf;AAAwC;;AAEjY,SAASG,YAAT,CAAsBC,OAAtB,EAA+B;AAAE,MAAIC,yBAAyB,GAAGC,yBAAyB,EAAzD;;AAA6D,SAAO,SAASC,oBAAT,GAAgC;AAAE,QAAIC,KAAK,GAAGC,eAAe,CAACL,OAAD,CAA3B;AAAA,QAAsCM,MAAtC;;AAA8C,QAAIL,yBAAJ,EAA+B;AAAE,UAAIM,SAAS,GAAGF,eAAe,CAAC,IAAD,CAAf,CAAsB/H,WAAtC;;AAAmDgI,MAAAA,MAAM,GAAGE,OAAO,CAACC,SAAR,CAAkBL,KAAlB,EAAyBM,SAAzB,EAAoCH,SAApC,CAAT;AAA0D,KAA9I,MAAoJ;AAAED,MAAAA,MAAM,GAAGF,KAAK,CAAChC,KAAN,CAAY,IAAZ,EAAkBsC,SAAlB,CAAT;AAAwC;;AAAC,WAAOC,0BAA0B,CAAC,IAAD,EAAOL,MAAP,CAAjC;AAAkD,GAAxU;AAA2U;;AAEza,SAASK,0BAAT,CAAoCC,IAApC,EAA0CnH,IAA1C,EAAgD;AAAE,MAAIA,IAAI,KAAKiF,SAAS,CAACjF,IAAD,CAAT,KAAoB,QAApB,IAAgC,OAAOA,IAAP,KAAgB,UAArD,CAAR,EAA0E;AAAE,WAAOA,IAAP;AAAc;;AAAC,SAAOoH,sBAAsB,CAACD,IAAD,CAA7B;AAAsC;;AAEnL,SAASC,sBAAT,CAAgCD,IAAhC,EAAsC;AAAE,MAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAE,UAAM,IAAIE,cAAJ,CAAmB,2DAAnB,CAAN;AAAwF;;AAAC,SAAOF,IAAP;AAAc;;AAEtK,SAASG,gBAAT,CAA0BC,KAA1B,EAAiC;AAAE,MAAIC,MAAM,GAAG,OAAOC,GAAP,KAAe,UAAf,GAA4B,IAAIA,GAAJ,EAA5B,GAAwChJ,SAArD;;AAAgE6I,EAAAA,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,KAA1B,EAAiC;AAAE,QAAIA,KAAK,KAAK,IAAV,IAAkB,CAACG,iBAAiB,CAACH,KAAD,CAAxC,EAAiD,OAAOA,KAAP;;AAAc,QAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;AAAE,YAAM,IAAIlC,SAAJ,CAAc,oDAAd,CAAN;AAA4E;;AAAC,QAAI,OAAOmC,MAAP,KAAkB,WAAtB,EAAmC;AAAE,UAAIA,MAAM,CAACG,GAAP,CAAWJ,KAAX,CAAJ,EAAuB,OAAOC,MAAM,CAACI,GAAP,CAAWL,KAAX,CAAP;;AAA0BC,MAAAA,MAAM,CAACtK,GAAP,CAAWqK,KAAX,EAAkBM,OAAlB;AAA6B;;AAAC,aAASA,OAAT,GAAmB;AAAE,aAAOC,UAAU,CAACP,KAAD,EAAQN,SAAR,EAAmBL,eAAe,CAAC,IAAD,CAAf,CAAsB/H,WAAzC,CAAjB;AAAyE;;AAACgJ,IAAAA,OAAO,CAAC/I,SAAR,GAAoByB,MAAM,CAAC6F,MAAP,CAAcmB,KAAK,CAACzI,SAApB,EAA+B;AAAED,MAAAA,WAAW,EAAE;AAAEK,QAAAA,KAAK,EAAE2I,OAAT;AAAkBnC,QAAAA,UAAU,EAAE,KAA9B;AAAqCE,QAAAA,QAAQ,EAAE,IAA/C;AAAqDD,QAAAA,YAAY,EAAE;AAAnE;AAAf,KAA/B,CAApB;AAAgJ,WAAOU,eAAe,CAACwB,OAAD,EAAUN,KAAV,CAAtB;AAAyC,GAAjnB;;AAAmnB,SAAOD,gBAAgB,CAACC,KAAD,CAAvB;AAAiC;;AAEvvB,SAASO,UAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkCT,KAAlC,EAAyC;AAAE,MAAId,yBAAyB,EAA7B,EAAiC;AAAEqB,IAAAA,UAAU,GAAGf,OAAO,CAACC,SAArB;AAAiC,GAApE,MAA0E;AAAEc,IAAAA,UAAU,GAAG,SAASA,UAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkCT,KAAlC,EAAyC;AAAE,UAAItK,CAAC,GAAG,CAAC,IAAD,CAAR;AAAgBA,MAAAA,CAAC,CAACoE,IAAF,CAAOsD,KAAP,CAAa1H,CAAb,EAAgB+K,IAAhB;AAAuB,UAAI5C,WAAW,GAAG6C,QAAQ,CAACC,IAAT,CAAcvD,KAAd,CAAoBoD,MAApB,EAA4B9K,CAA5B,CAAlB;AAAkD,UAAIkI,QAAQ,GAAG,IAAIC,WAAJ,EAAf;AAAkC,UAAImC,KAAJ,EAAWlB,eAAe,CAAClB,QAAD,EAAWoC,KAAK,CAACzI,SAAjB,CAAf;AAA4C,aAAOqG,QAAP;AAAkB,KAA5P;AAA+P;;AAAC,SAAO2C,UAAU,CAACnD,KAAX,CAAiB,IAAjB,EAAuBsC,SAAvB,CAAP;AAA2C;;AAEla,SAASR,yBAAT,GAAqC;AAAE,MAAI,OAAOM,OAAP,KAAmB,WAAnB,IAAkC,CAACA,OAAO,CAACC,SAA/C,EAA0D,OAAO,KAAP;AAAc,MAAID,OAAO,CAACC,SAAR,CAAkBmB,IAAtB,EAA4B,OAAO,KAAP;AAAc,MAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC,OAAO,IAAP;;AAAa,MAAI;AAAEC,IAAAA,IAAI,CAACvJ,SAAL,CAAeyC,QAAf,CAAwBvB,IAAxB,CAA6B+G,OAAO,CAACC,SAAR,CAAkBqB,IAAlB,EAAwB,EAAxB,EAA4B,YAAY,CAAE,CAA1C,CAA7B;AAA2E,WAAO,IAAP;AAAc,GAA/F,CAAgG,OAAO3K,CAAP,EAAU;AAAE,WAAO,KAAP;AAAe;AAAE;;AAEpU,SAASgK,iBAAT,CAA2BY,EAA3B,EAA+B;AAAE,SAAOL,QAAQ,CAAC1G,QAAT,CAAkBvB,IAAlB,CAAuBsI,EAAvB,EAA2B1I,OAA3B,CAAmC,eAAnC,MAAwD,CAAC,CAAhE;AAAoE;;AAErG,SAASyG,eAAT,CAAyBkC,CAAzB,EAA4BC,CAA5B,EAA+B;AAAEnC,EAAAA,eAAe,GAAG9F,MAAM,CAACkI,cAAP,IAAyB,SAASpC,eAAT,CAAyBkC,CAAzB,EAA4BC,CAA5B,EAA+B;AAAED,IAAAA,CAAC,CAACG,SAAF,GAAcF,CAAd;AAAiB,WAAOD,CAAP;AAAW,GAAxG;;AAA0G,SAAOlC,eAAe,CAACkC,CAAD,EAAIC,CAAJ,CAAtB;AAA+B;;AAE1K,SAAS5B,eAAT,CAAyB2B,CAAzB,EAA4B;AAAE3B,EAAAA,eAAe,GAAGrG,MAAM,CAACkI,cAAP,GAAwBlI,MAAM,CAACoI,cAA/B,GAAgD,SAAS/B,eAAT,CAAyB2B,CAAzB,EAA4B;AAAE,WAAOA,CAAC,CAACG,SAAF,IAAenI,MAAM,CAACoI,cAAP,CAAsBJ,CAAtB,CAAtB;AAAiD,GAAjJ;AAAmJ,SAAO3B,eAAe,CAAC2B,CAAD,CAAtB;AAA4B;AAC7M;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIK,YAAY,GAAG,aAAa,UAAUC,MAAV,EAAkB;AAChD5C,EAAAA,SAAS,CAAC2C,YAAD,EAAeC,MAAf,CAAT;;AAEA,MAAIC,MAAM,GAAGxC,YAAY,CAACsC,YAAD,CAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;;AACE,WAASA,YAAT,CAAsBjH,OAAtB,EAA+BoH,KAA/B,EAAsC3G,MAAtC,EAA8C4G,SAA9C,EAAyDC,IAAzD,EAA+DC,aAA/D,EAA8EC,UAA9E,EAA0F;AACxF,QAAIC,WAAJ,EAAiBC,QAAjB,EAA2BC,WAA3B,EAAwCC,YAAxC;;AAEA,QAAIC,KAAJ;;AAEAtE,IAAAA,eAAe,CAAC,IAAD,EAAO0D,YAAP,CAAf;;AAEAY,IAAAA,KAAK,GAAGV,MAAM,CAAC9I,IAAP,CAAY,IAAZ,EAAkB2B,OAAlB,CAAR,CAPwF,CAOpD;;AAEpC,QAAI8H,MAAM,GAAGxJ,KAAK,CAACC,OAAN,CAAc6I,KAAd,IAAuBA,KAAK,CAACvI,MAAN,KAAiB,CAAjB,GAAqBuI,KAArB,GAA6BtK,SAApD,GAAgEsK,KAAK,GAAG,CAACA,KAAD,CAAH,GAAatK,SAA/F,CATwF,CASkB;;;AAG1G,QAAIiL,OAAO,GAAGtH,MAAd;;AAEA,QAAI,CAACsH,OAAD,IAAYD,MAAhB,EAAwB;AACtB,UAAIE,YAAJ;;AAEAD,MAAAA,OAAO,GAAG,CAACC,YAAY,GAAGF,MAAM,CAAC,CAAD,CAAN,CAAUG,GAA1B,MAAmC,IAAnC,IAA2CD,YAAY,KAAK,KAAK,CAAjE,GAAqE,KAAK,CAA1E,GAA8EA,YAAY,CAACvH,MAArG;AACD;;AAED,QAAIyH,UAAU,GAAGb,SAAjB;;AAEA,QAAI,CAACa,UAAD,IAAeJ,MAAnB,EAA2B;AACzBI,MAAAA,UAAU,GAAGJ,MAAM,CAACK,MAAP,CAAc,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAC/C,YAAIA,IAAI,CAACJ,GAAT,EAAc;AACZG,UAAAA,IAAI,CAAC1I,IAAL,CAAU2I,IAAI,CAACJ,GAAL,CAAS5G,KAAnB;AACD;;AAED,eAAO+G,IAAP;AACD,OANY,EAMV,EANU,CAAb;AAOD;;AAED,QAAIF,UAAU,IAAIA,UAAU,CAACrJ,MAAX,KAAsB,CAAxC,EAA2C;AACzCqJ,MAAAA,UAAU,GAAGpL,SAAb;AACD;;AAED,QAAIwL,UAAJ;;AAEA,QAAIjB,SAAS,IAAI5G,MAAjB,EAAyB;AACvB6H,MAAAA,UAAU,GAAGjB,SAAS,CAACrI,GAAV,CAAc,UAAUuJ,GAAV,EAAe;AACxC,eAAO/H,WAAW,CAACC,MAAD,EAAS8H,GAAT,CAAlB;AACD,OAFY,CAAb;AAGD,KAJD,MAIO,IAAIT,MAAJ,EAAY;AACjBQ,MAAAA,UAAU,GAAGR,MAAM,CAACK,MAAP,CAAc,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAC/C,YAAIA,IAAI,CAACJ,GAAT,EAAc;AACZG,UAAAA,IAAI,CAAC1I,IAAL,CAAUc,WAAW,CAAC6H,IAAI,CAACJ,GAAL,CAASxH,MAAV,EAAkB4H,IAAI,CAACJ,GAAL,CAAS5G,KAA3B,CAArB;AACD;;AAED,eAAO+G,IAAP;AACD,OANY,EAMV,EANU,CAAb;AAOD;;AAED,QAAII,WAAW,GAAGhB,UAAlB;;AAEA,QAAIgB,WAAW,IAAI,IAAf,IAAuBjB,aAAa,IAAI,IAA5C,EAAkD;AAChD,UAAIkB,kBAAkB,GAAGlB,aAAa,CAACC,UAAvC;;AAEA,UAAInH,YAAY,CAACoI,kBAAD,CAAhB,EAAsC;AACpCD,QAAAA,WAAW,GAAGC,kBAAd;AACD;AACF;;AAED7J,IAAAA,MAAM,CAAC8J,gBAAP,CAAwBjD,sBAAsB,CAACoC,KAAD,CAA9C,EAAuD;AACrDjK,MAAAA,IAAI,EAAE;AACJL,QAAAA,KAAK,EAAE;AADH,OAD+C;AAIrDyC,MAAAA,OAAO,EAAE;AACPzC,QAAAA,KAAK,EAAEyC,OADA;AAEP;AACA;AACA;AACA+D,QAAAA,UAAU,EAAE,IALL;AAMPE,QAAAA,QAAQ,EAAE;AANH,OAJ4C;AAYrD0E,MAAAA,SAAS,EAAE;AACT;AACA;AACApL,QAAAA,KAAK,EAAE,CAACkK,WAAW,GAAGa,UAAf,MAA+B,IAA/B,IAAuCb,WAAW,KAAK,KAAK,CAA5D,GAAgEA,WAAhE,GAA8E3K,SAH5E;AAIT;AACA;AACA;AACAiH,QAAAA,UAAU,EAAEuE,UAAU,IAAI;AAPjB,OAZ0C;AAqBrDhB,MAAAA,IAAI,EAAE;AACJ;AACA;AACA/J,QAAAA,KAAK,EAAE+J,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmCA,IAAnC,GAA0CxK,SAH7C;AAIJ;AACA;AACA;AACAiH,QAAAA,UAAU,EAAEuD,IAAI,IAAI;AAPhB,OArB+C;AA8BrDF,MAAAA,KAAK,EAAE;AACL7J,QAAAA,KAAK,EAAEuK,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuCA,MAAvC,GAAgDhL;AADlD,OA9B8C;AAiCrD2D,MAAAA,MAAM,EAAE;AACNlD,QAAAA,KAAK,EAAE,CAACmK,QAAQ,GAAGK,OAAZ,MAAyB,IAAzB,IAAiCL,QAAQ,KAAK,KAAK,CAAnD,GAAuDA,QAAvD,GAAkE5K;AADnE,OAjC6C;AAoCrDuK,MAAAA,SAAS,EAAE;AACT9J,QAAAA,KAAK,EAAE,CAACoK,WAAW,GAAGO,UAAf,MAA+B,IAA/B,IAAuCP,WAAW,KAAK,KAAK,CAA5D,GAAgEA,WAAhE,GAA8E7K;AAD5E,OApC0C;AAuCrDyK,MAAAA,aAAa,EAAE;AACbhK,QAAAA,KAAK,EAAEgK;AADM,OAvCsC;AA0CrDC,MAAAA,UAAU,EAAE;AACV;AACA;AACAjK,QAAAA,KAAK,EAAE,CAACqK,YAAY,GAAGY,WAAhB,MAAiC,IAAjC,IAAyCZ,YAAY,KAAK,KAAK,CAA/D,GAAmEA,YAAnE,GAAkF9K,SAH/E;AAIV;AACA;AACA;AACAiH,QAAAA,UAAU,EAAEyE,WAAW,IAAI;AAPjB;AA1CyC,KAAvD,EA9DwF,CAiHpF;;AAEJ,QAAIjB,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACqB,KAAhF,EAAuF;AACrFhK,MAAAA,MAAM,CAACsF,cAAP,CAAsBuB,sBAAsB,CAACoC,KAAD,CAA5C,EAAqD,OAArD,EAA8D;AAC5DtK,QAAAA,KAAK,EAAEgK,aAAa,CAACqB,KADuC;AAE5D3E,QAAAA,QAAQ,EAAE,IAFkD;AAG5DD,QAAAA,YAAY,EAAE;AAH8C,OAA9D;AAKA,aAAOuB,0BAA0B,CAACsC,KAAD,CAAjC;AACD,KA1HuF,CA0HtF;;;AAGF,QAAI1H,KAAK,CAAC0I,iBAAV,EAA6B;AAC3B1I,MAAAA,KAAK,CAAC0I,iBAAN,CAAwBpD,sBAAsB,CAACoC,KAAD,CAA9C,EAAuDZ,YAAvD;AACD,KAFD,MAEO;AACLrI,MAAAA,MAAM,CAACsF,cAAP,CAAsBuB,sBAAsB,CAACoC,KAAD,CAA5C,EAAqD,OAArD,EAA8D;AAC5DtK,QAAAA,KAAK,EAAE4C,KAAK,GAAGyI,KAD6C;AAE5D3E,QAAAA,QAAQ,EAAE,IAFkD;AAG5DD,QAAAA,YAAY,EAAE;AAH8C,OAA9D;AAKD;;AAED,WAAO6D,KAAP;AACD;;AAED1D,EAAAA,YAAY,CAAC8C,YAAD,EAAe,CAAC;AAC1BhI,IAAAA,GAAG,EAAE,UADqB;AAE1B1B,IAAAA,KAAK,EAAE,SAASqC,QAAT,GAAoB;AACzB,aAAOkJ,UAAU,CAAC,IAAD,CAAjB;AACD,KAJyB,CAIxB;AACF;;AAL0B,GAAD,EAOxB;AACD7J,IAAAA,GAAG,EAAEqB,oBADJ;AAED2F,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,QAAP;AACD;AAJA,GAPwB,CAAf,CAAZ;;AAcA,SAAOgB,YAAP;AACD,CA/M+B,EA+M7B,aAAatB,gBAAgB,CAACxF,KAAD,CA/MA,CAAhC;AAgNA;AACA;AACA;AACA;;;AAEA,SAAS2I,UAAT,CAAoBC,KAApB,EAA2B;AACzB,MAAIC,MAAM,GAAGD,KAAK,CAAC/I,OAAnB;;AAEA,MAAI+I,KAAK,CAAC3B,KAAV,EAAiB;AACf,SAAK,IAAI6B,GAAG,GAAG,CAAV,EAAaC,aAAa,GAAGH,KAAK,CAAC3B,KAAxC,EAA+C6B,GAAG,GAAGC,aAAa,CAACrK,MAAnE,EAA2EoK,GAAG,EAA9E,EAAkF;AAChF,UAAIZ,IAAI,GAAGa,aAAa,CAACD,GAAD,CAAxB;;AAEA,UAAIZ,IAAI,CAACJ,GAAT,EAAc;AACZe,QAAAA,MAAM,IAAI,SAAS9H,aAAa,CAACmH,IAAI,CAACJ,GAAN,CAAhC;AACD;AACF;AACF,GARD,MAQO,IAAIc,KAAK,CAACtI,MAAN,IAAgBsI,KAAK,CAACJ,SAA1B,EAAqC;AAC1C,SAAK,IAAIQ,GAAG,GAAG,CAAV,EAAaC,iBAAiB,GAAGL,KAAK,CAACJ,SAA5C,EAAuDQ,GAAG,GAAGC,iBAAiB,CAACvK,MAA/E,EAAuFsK,GAAG,EAA1F,EAA8F;AAC5F,UAAIhI,QAAQ,GAAGiI,iBAAiB,CAACD,GAAD,CAAhC;AACAH,MAAAA,MAAM,IAAI,SAAS5H,mBAAmB,CAAC2H,KAAK,CAACtI,MAAP,EAAeU,QAAf,CAAtC;AACD;AACF;;AAED,SAAO6H,MAAP;AACD;AAED;AACA;AACA;AACA;;;AAEA,SAASK,WAAT,CAAqB5I,MAArB,EAA6BC,QAA7B,EAAuC4I,WAAvC,EAAoD;AAClD,SAAO,IAAIrC,YAAJ,CAAiB,iBAAiBpJ,MAAjB,CAAwByL,WAAxB,CAAjB,EAAuDxM,SAAvD,EAAkE2D,MAAlE,EAA0E,CAACC,QAAD,CAA1E,CAAP;AACD;AAED;AACA;AACA;;;AACA,IAAI6I,IAAI,GAAG3K,MAAM,CAAC4K,MAAP,CAAc;AACvB;AACAC,EAAAA,IAAI,EAAE,MAFiB;AAGvB;AACAC,EAAAA,QAAQ,EAAE,UAJa;AAKvBC,EAAAA,oBAAoB,EAAE,qBALC;AAMvBC,EAAAA,mBAAmB,EAAE,oBANE;AAOvBC,EAAAA,aAAa,EAAE,cAPQ;AAQvBC,EAAAA,KAAK,EAAE,OARgB;AASvBC,EAAAA,QAAQ,EAAE,UATa;AAUvB;AACAC,EAAAA,eAAe,EAAE,gBAXM;AAYvBC,EAAAA,eAAe,EAAE,gBAZM;AAavBC,EAAAA,mBAAmB,EAAE,oBAbE;AAcvB;AACAC,EAAAA,QAAQ,EAAE,UAfa;AAgBvBC,EAAAA,GAAG,EAAE,UAhBkB;AAiBvBC,EAAAA,KAAK,EAAE,YAjBgB;AAkBvBC,EAAAA,MAAM,EAAE,aAlBe;AAmBvBC,EAAAA,OAAO,EAAE,cAnBc;AAoBvBC,EAAAA,IAAI,EAAE,WApBiB;AAqBvBC,EAAAA,IAAI,EAAE,WArBiB;AAsBvBC,EAAAA,IAAI,EAAE,WAtBiB;AAuBvBC,EAAAA,MAAM,EAAE,aAvBe;AAwBvBC,EAAAA,YAAY,EAAE,aAxBS;AAyBvB;AACAC,EAAAA,SAAS,EAAE,WA1BY;AA2BvB;AACAC,EAAAA,UAAU,EAAE,WA5BW;AA6BvBC,EAAAA,SAAS,EAAE,UA7BY;AA8BvBC,EAAAA,aAAa,EAAE,aA9BQ;AA+BvB;AACAC,EAAAA,iBAAiB,EAAE,kBAhCI;AAiCvBC,EAAAA,yBAAyB,EAAE,yBAjCJ;AAkCvB;AACAC,EAAAA,sBAAsB,EAAE,sBAnCD;AAoCvBC,EAAAA,sBAAsB,EAAE,sBApCD;AAqCvBC,EAAAA,gBAAgB,EAAE,iBArCK;AAsCvBC,EAAAA,sBAAsB,EAAE,sBAtCD;AAuCvBC,EAAAA,yBAAyB,EAAE,yBAvCJ;AAwCvBC,EAAAA,qBAAqB,EAAE,qBAxCA;AAyCvBC,EAAAA,oBAAoB,EAAE,oBAzCC;AA0CvBC,EAAAA,qBAAqB,EAAE,qBA1CA;AA2CvBC,EAAAA,4BAA4B,EAAE,2BA3CP;AA4CvB;AACAC,EAAAA,oBAAoB,EAAE,qBA7CC;AA8CvB;AACAC,EAAAA,gBAAgB,EAAE,iBA/CK;AAgDvB;AACAC,EAAAA,qBAAqB,EAAE,qBAjDA;AAkDvBC,EAAAA,qBAAqB,EAAE,qBAlDA;AAmDvBC,EAAAA,wBAAwB,EAAE,wBAnDH;AAoDvBC,EAAAA,oBAAoB,EAAE,oBApDC;AAqDvBC,EAAAA,mBAAmB,EAAE,mBArDE;AAsDvBC,EAAAA,2BAA2B,EAAE;AAtDN,CAAd,CAAX;AAwDA;AACA;AACA;;AAEA,SAASC,SAAT,CAAmBrM,SAAnB,EAA8BC,OAA9B,EAAuC;AACrC,MAAIC,gBAAgB,GAAGC,OAAO,CAACH,SAAD,CAA9B,CADqC,CACM;;AAE3C,MAAI,CAACE,gBAAL,EAAuB;AACrB,UAAM,IAAIE,KAAJ,CAAUH,OAAO,IAAI,IAAX,GAAkBA,OAAlB,GAA4B,iCAAtC,CAAN;AACD;AACF;AAED;AACA;AACA;;;AAEA,SAASqM,aAAT,CAAuBC,WAAvB,EAAoC;AAClC,MAAI3F,EAAE,GAAG2F,WAAW,CAACnP,SAAZ,CAAsBoP,MAA/B;AACA,SAAO5F,EAAP,KAAc,UAAd,IAA4ByF,SAAS,CAAC,CAAD,CAArC;AACAE,EAAAA,WAAW,CAACnP,SAAZ,CAAsBG,OAAtB,GAAgCqJ,EAAhC,CAHkC,CAGE;;AAEpC,MAAIhK,yBAAJ,EAA+B;AAC7B2P,IAAAA,WAAW,CAACnP,SAAZ,CAAsBR,yBAAtB,IAAmDgK,EAAnD;AACD;AACF;AAED;AACA;AACA;AACA;;;AACA,IAAI6F,QAAQ,GAAG,aAAa,YAAY;AACtC;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;AACE,WAASA,QAAT,CAAkBC,UAAlB,EAA8BC,QAA9B,EAAwCjM,MAAxC,EAAgD;AAC9C,SAAKY,KAAL,GAAaoL,UAAU,CAACpL,KAAxB;AACA,SAAKsL,GAAL,GAAWD,QAAQ,CAACC,GAApB;AACA,SAAKF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKjM,MAAL,GAAcA,MAAd;AACD;;AAED,MAAImM,MAAM,GAAGJ,QAAQ,CAACrP,SAAtB;;AAEAyP,EAAAA,MAAM,CAACL,MAAP,GAAgB,SAASA,MAAT,GAAkB;AAChC,WAAO;AACLlL,MAAAA,KAAK,EAAE,KAAKA,KADP;AAELsL,MAAAA,GAAG,EAAE,KAAKA;AAFL,KAAP;AAID,GALD;;AAOA,SAAOH,QAAP;AACD,CAtC2B,EAA5B,C,CAsCK;;;AAELH,aAAa,CAACG,QAAD,CAAb;AACA;AACA;AACA;AACA;;AAEA,IAAIK,KAAK,GAAG,aAAa,YAAY;AACnC;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;AACA;AACA;AACE,WAASA,KAAT,CAAeC,IAAf,EAAqBzL,KAArB,EAA4BsL,GAA5B,EAAiC/L,IAAjC,EAAuCC,MAAvC,EAA+CkM,IAA/C,EAAqDxP,KAArD,EAA4D;AAC1D,SAAKuP,IAAL,GAAYA,IAAZ;AACA,SAAKzL,KAAL,GAAaA,KAAb;AACA,SAAKsL,GAAL,GAAWA,GAAX;AACA,SAAK/L,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKtD,KAAL,GAAaA,KAAb;AACA,SAAKwP,IAAL,GAAYA,IAAZ;AACA,SAAKC,IAAL,GAAY,IAAZ;AACD;;AAED,MAAIC,OAAO,GAAGJ,KAAK,CAAC1P,SAApB;;AAEA8P,EAAAA,OAAO,CAACV,MAAR,GAAiB,SAASA,MAAT,GAAkB;AACjC,WAAO;AACLO,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELvP,MAAAA,KAAK,EAAE,KAAKA,KAFP;AAGLqD,MAAAA,IAAI,EAAE,KAAKA,IAHN;AAILC,MAAAA,MAAM,EAAE,KAAKA;AAJR,KAAP;AAMD,GAPD;;AASA,SAAOgM,KAAP;AACD,CArDwB,EAAzB,C,CAqDK;;;AAELR,aAAa,CAACQ,KAAD,CAAb;AACA;AACA;AACA;;AAEA,SAASK,mBAAT,CAA6BtJ,MAA7B,EAAqCC,KAArC,EAA4C;AAAE,OAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoE,KAAK,CAAChF,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AAAE,QAAIqE,UAAU,GAAGD,KAAK,CAACpE,CAAD,CAAtB;AAA2BqE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BrF,IAAAA,MAAM,CAACsF,cAAP,CAAsBN,MAAtB,EAA8BE,UAAU,CAAC7E,GAAzC,EAA8C6E,UAA9C;AAA4D;AAAE;;AAE/T,SAASqJ,cAAT,CAAwB1J,WAAxB,EAAqCW,UAArC,EAAiDC,WAAjD,EAA8D;AAAE,MAAID,UAAJ,EAAgB8I,mBAAmB,CAACzJ,WAAW,CAACtG,SAAb,EAAwBiH,UAAxB,CAAnB;AAAwD,MAAIC,WAAJ,EAAiB6I,mBAAmB,CAACzJ,WAAD,EAAcY,WAAd,CAAnB;AAA+C,SAAOZ,WAAP;AAAqB;AAE7N;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI2J,MAAM,GAAG,aAAa,YAAY;AACpC,WAASA,MAAT,CAAgBpM,IAAhB,EAAsB;AACpB,QAAIpD,IAAI,GAAG0H,SAAS,CAACzG,MAAV,GAAmB,CAAnB,IAAwByG,SAAS,CAAC,CAAD,CAAT,KAAiBxI,SAAzC,GAAqDwI,SAAS,CAAC,CAAD,CAA9D,GAAoE,iBAA/E;AACA,QAAI9D,cAAc,GAAG8D,SAAS,CAACzG,MAAV,GAAmB,CAAnB,IAAwByG,SAAS,CAAC,CAAD,CAAT,KAAiBxI,SAAzC,GAAqDwI,SAAS,CAAC,CAAD,CAA9D,GAAoE;AACvF1E,MAAAA,IAAI,EAAE,CADiF;AAEvFC,MAAAA,MAAM,EAAE;AAF+E,KAAzF;AAIA,SAAKG,IAAL,GAAYA,IAAZ;AACA,SAAKpD,IAAL,GAAYA,IAAZ;AACA,SAAK4D,cAAL,GAAsBA,cAAtB;AACA,SAAKA,cAAL,CAAoBZ,IAApB,GAA2B,CAA3B,IAAgCd,SAAS,CAAC,CAAD,EAAI,2DAAJ,CAAzC;AACA,SAAK0B,cAAL,CAAoBX,MAApB,GAA6B,CAA7B,IAAkCf,SAAS,CAAC,CAAD,EAAI,6DAAJ,CAA3C;AACD,GAZmC,CAYlC;;;AAGFqN,EAAAA,cAAc,CAACC,MAAD,EAAS,CAAC;AACtBnO,IAAAA,GAAG,EAAEqB,oBADiB;AAEtB2F,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,QAAP;AACD;AAJqB,GAAD,CAAT,CAAd;;AAOA,SAAOmH,MAAP;AACD,CAvByB,EAA1B;AAyBA;AACA;AACA;AACA;;;AACA,IAAIC,SAAS,GAAGzO,MAAM,CAAC4K,MAAP,CAAc;AAC5B8D,EAAAA,GAAG,EAAE,OADuB;AAE5BC,EAAAA,GAAG,EAAE,OAFuB;AAG5BC,EAAAA,IAAI,EAAE,GAHsB;AAI5BC,EAAAA,MAAM,EAAE,GAJoB;AAK5BC,EAAAA,GAAG,EAAE,GALuB;AAM5BC,EAAAA,OAAO,EAAE,GANmB;AAO5BC,EAAAA,OAAO,EAAE,GAPmB;AAQ5BC,EAAAA,MAAM,EAAE,KARoB;AAS5BC,EAAAA,KAAK,EAAE,GATqB;AAU5BC,EAAAA,MAAM,EAAE,GAVoB;AAW5BC,EAAAA,EAAE,EAAE,GAXwB;AAY5BC,EAAAA,SAAS,EAAE,GAZiB;AAa5BC,EAAAA,SAAS,EAAE,GAbiB;AAc5BC,EAAAA,OAAO,EAAE,GAdmB;AAe5BC,EAAAA,IAAI,EAAE,GAfsB;AAgB5BC,EAAAA,OAAO,EAAE,GAhBmB;AAiB5B5E,EAAAA,IAAI,EAAE,MAjBsB;AAkB5BW,EAAAA,GAAG,EAAE,KAlBuB;AAmB5BC,EAAAA,KAAK,EAAE,OAnBqB;AAoB5BC,EAAAA,MAAM,EAAE,QApBoB;AAqB5BgE,EAAAA,YAAY,EAAE,aArBc;AAsB5BC,EAAAA,OAAO,EAAE;AAtBmB,CAAd,CAAhB;AAwBA;AACA;AACA;;AAEA;AACA;AACA;;AACA,IAAIC,iBAAiB,GAAG5P,MAAM,CAAC4K,MAAP,CAAc;AACpC;AACAiF,EAAAA,KAAK,EAAE,OAF6B;AAGpCC,EAAAA,QAAQ,EAAE,UAH0B;AAIpCC,EAAAA,YAAY,EAAE,cAJsB;AAKpC7E,EAAAA,KAAK,EAAE,OAL6B;AAMpCI,EAAAA,mBAAmB,EAAE,qBANe;AAOpCF,EAAAA,eAAe,EAAE,iBAPmB;AAQpCC,EAAAA,eAAe,EAAE,iBARmB;AASpCL,EAAAA,mBAAmB,EAAE,qBATe;AAUpC;AACAgF,EAAAA,MAAM,EAAE,QAX4B;AAYpCC,EAAAA,MAAM,EAAE,QAZ4B;AAapClE,EAAAA,MAAM,EAAE,QAb4B;AAcpCU,EAAAA,gBAAgB,EAAE,kBAdkB;AAepCyD,EAAAA,mBAAmB,EAAE,qBAfe;AAgBpCC,EAAAA,SAAS,EAAE,WAhByB;AAiBpCC,EAAAA,KAAK,EAAE,OAjB6B;AAkBpCvE,EAAAA,IAAI,EAAE,MAlB8B;AAmBpCwE,EAAAA,UAAU,EAAE,YAnBwB;AAoBpCC,EAAAA,YAAY,EAAE,cApBsB;AAqBpCC,EAAAA,sBAAsB,EAAE;AArBY,CAAd,CAAxB;AAuBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,sBAAT,CAAgCC,SAAhC,EAA2C;AACzC;AACA,MAAIrN,KAAK,GAAGqN,SAAS,CAACpN,KAAV,CAAgB,cAAhB,CAAZ,CAFyC,CAEI;;AAE7C,MAAIqN,YAAY,GAAGC,yBAAyB,CAACvN,KAAD,CAA5C;;AAEA,MAAIsN,YAAY,KAAK,CAArB,EAAwB;AACtB,SAAK,IAAI7P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,KAAK,CAACnD,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACrCuC,MAAAA,KAAK,CAACvC,CAAD,CAAL,GAAWuC,KAAK,CAACvC,CAAD,CAAL,CAAS8C,KAAT,CAAe+M,YAAf,CAAX;AACD;AACF,GAVwC,CAUvC;;;AAGF,SAAOtN,KAAK,CAACnD,MAAN,GAAe,CAAf,IAAoB2Q,OAAO,CAACxN,KAAK,CAAC,CAAD,CAAN,CAAlC,EAA8C;AAC5CA,IAAAA,KAAK,CAACyN,KAAN;AACD;;AAED,SAAOzN,KAAK,CAACnD,MAAN,GAAe,CAAf,IAAoB2Q,OAAO,CAACxN,KAAK,CAACA,KAAK,CAACnD,MAAN,GAAe,CAAhB,CAAN,CAAlC,EAA6D;AAC3DmD,IAAAA,KAAK,CAAC0N,GAAN;AACD,GAnBwC,CAmBvC;;;AAGF,SAAO1N,KAAK,CAAC9C,IAAN,CAAW,IAAX,CAAP;AACD;AACD;AACA;AACA;;;AAEA,SAASqQ,yBAAT,CAAmCvN,KAAnC,EAA0C;AACxC,MAAIsN,YAAY,GAAG,IAAnB;;AAEA,OAAK,IAAI7P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,KAAK,CAACnD,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACrC,QAAImB,IAAI,GAAGoB,KAAK,CAACvC,CAAD,CAAhB;AACA,QAAIkQ,MAAM,GAAGC,iBAAiB,CAAChP,IAAD,CAA9B;;AAEA,QAAI+O,MAAM,KAAK/O,IAAI,CAAC/B,MAApB,EAA4B;AAC1B,eAD0B,CAChB;AACX;;AAED,QAAIyQ,YAAY,KAAK,IAAjB,IAAyBK,MAAM,GAAGL,YAAtC,EAAoD;AAClDA,MAAAA,YAAY,GAAGK,MAAf;;AAEA,UAAIL,YAAY,KAAK,CAArB,EAAwB;AACtB;AACD;AACF;AACF;;AAED,SAAOA,YAAY,KAAK,IAAjB,GAAwB,CAAxB,GAA4BA,YAAnC;AACD;;AAED,SAASM,iBAAT,CAA2BvM,GAA3B,EAAgC;AAC9B,MAAI5D,CAAC,GAAG,CAAR;;AAEA,SAAOA,CAAC,GAAG4D,GAAG,CAACxE,MAAR,KAAmBwE,GAAG,CAAC5D,CAAD,CAAH,KAAW,GAAX,IAAkB4D,GAAG,CAAC5D,CAAD,CAAH,KAAW,IAAhD,CAAP,EAA8D;AAC5DA,IAAAA,CAAC;AACF;;AAED,SAAOA,CAAP;AACD;;AAED,SAAS+P,OAAT,CAAiBnM,GAAjB,EAAsB;AACpB,SAAOuM,iBAAiB,CAACvM,GAAD,CAAjB,KAA2BA,GAAG,CAACxE,MAAtC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIgR,KAAK,GAAG,aAAa,YAAY;AACnC;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;AACE,WAASA,KAAT,CAAepP,MAAf,EAAuB;AACrB,QAAIqP,gBAAgB,GAAG,IAAIjD,KAAJ,CAAUQ,SAAS,CAACC,GAApB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,IAArC,CAAvB;AACA,SAAK7M,MAAL,GAAcA,MAAd;AACA,SAAKsP,SAAL,GAAiBD,gBAAjB;AACA,SAAKE,KAAL,GAAaF,gBAAb;AACA,SAAKlP,IAAL,GAAY,CAAZ;AACA,SAAKqP,SAAL,GAAiB,CAAjB;AACD;AACD;AACF;AACA;;;AAGE,MAAIrD,MAAM,GAAGiD,KAAK,CAAC1S,SAAnB;;AAEAyP,EAAAA,MAAM,CAACsD,OAAP,GAAiB,SAASA,OAAT,GAAmB;AAClC,SAAKH,SAAL,GAAiB,KAAKC,KAAtB;AACA,QAAIA,KAAK,GAAG,KAAKA,KAAL,GAAa,KAAKG,SAAL,EAAzB;AACA,WAAOH,KAAP;AACD;AACD;AACF;AACA;AACA;AARE;;AAWApD,EAAAA,MAAM,CAACuD,SAAP,GAAmB,SAASA,SAAT,GAAqB;AACtC,QAAIH,KAAK,GAAG,KAAKA,KAAjB;;AAEA,QAAIA,KAAK,CAAClD,IAAN,KAAeO,SAAS,CAACE,GAA7B,EAAkC;AAChC,SAAG;AACD,YAAI6C,WAAJ,CADC,CAGD;;;AACAJ,QAAAA,KAAK,GAAG,CAACI,WAAW,GAAGJ,KAAK,CAAChD,IAArB,MAA+B,IAA/B,IAAuCoD,WAAW,KAAK,KAAK,CAA5D,GAAgEA,WAAhE,GAA8EJ,KAAK,CAAChD,IAAN,GAAaqD,SAAS,CAAC,IAAD,EAAOL,KAAP,CAA5G;AACD,OALD,QAKSA,KAAK,CAAClD,IAAN,KAAeO,SAAS,CAACkB,OALlC;AAMD;;AAED,WAAOyB,KAAP;AACD,GAbD;;AAeA,SAAOH,KAAP;AACD,CA1DwB,EAAzB;AA2DA;AACA;AACA;;;AAEA,SAASS,qBAAT,CAA+BxD,IAA/B,EAAqC;AACnC,SAAOA,IAAI,KAAKO,SAAS,CAACG,IAAnB,IAA2BV,IAAI,KAAKO,SAAS,CAACI,MAA9C,IAAwDX,IAAI,KAAKO,SAAS,CAACK,GAA3E,IAAkFZ,IAAI,KAAKO,SAAS,CAACM,OAArG,IAAgHb,IAAI,KAAKO,SAAS,CAACO,OAAnI,IAA8Id,IAAI,KAAKO,SAAS,CAACQ,MAAjK,IAA2Kf,IAAI,KAAKO,SAAS,CAACS,KAA9L,IAAuMhB,IAAI,KAAKO,SAAS,CAACU,MAA1N,IAAoOjB,IAAI,KAAKO,SAAS,CAACW,EAAvP,IAA6PlB,IAAI,KAAKO,SAAS,CAACY,SAAhR,IAA6RnB,IAAI,KAAKO,SAAS,CAACa,SAAhT,IAA6TpB,IAAI,KAAKO,SAAS,CAACc,OAAhV,IAA2VrB,IAAI,KAAKO,SAAS,CAACe,IAA9W,IAAsXtB,IAAI,KAAKO,SAAS,CAACgB,OAAhZ;AACD;;AAED,SAASkC,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,SAAQ;AACNC,IAAAA,KAAK,CAACD,IAAD,CAAL,GAAcnD,SAAS,CAACE,GAAxB,GAA8B;AAC9BiD,IAAAA,IAAI,GAAG,MAAP,GAAgB9S,IAAI,CAACC,SAAL,CAAeI,MAAM,CAAC2S,YAAP,CAAoBF,IAApB,CAAf,CAAhB,GAA4D;AAC5D,YAAQ3S,MAAR,CAAe,CAAC,OAAO2S,IAAI,CAAC5Q,QAAL,CAAc,EAAd,EAAkB+Q,WAAlB,EAAR,EAAyCpO,KAAzC,CAA+C,CAAC,CAAhD,CAAf,EAAmE,IAAnE;AAHF;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS8N,SAAT,CAAmBO,KAAnB,EAA0B7D,IAA1B,EAAgC;AAC9B,MAAItM,MAAM,GAAGmQ,KAAK,CAACnQ,MAAnB;AACA,MAAIO,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAI6P,UAAU,GAAG7P,IAAI,CAACnC,MAAtB;AACA,MAAI0J,GAAG,GAAGuI,uBAAuB,CAAC9P,IAAD,EAAO+L,IAAI,CAACJ,GAAZ,EAAiBiE,KAAjB,CAAjC;AACA,MAAIhQ,IAAI,GAAGgQ,KAAK,CAAChQ,IAAjB;AACA,MAAImQ,GAAG,GAAG,IAAIxI,GAAJ,GAAUqI,KAAK,CAACX,SAA1B;;AAEA,MAAI1H,GAAG,IAAIsI,UAAX,EAAuB;AACrB,WAAO,IAAIhE,KAAJ,CAAUQ,SAAS,CAACE,GAApB,EAAyBsD,UAAzB,EAAqCA,UAArC,EAAiDjQ,IAAjD,EAAuDmQ,GAAvD,EAA4DhE,IAA5D,CAAP;AACD;;AAED,MAAIyD,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBzI,GAAhB,CAAX,CAZ8B,CAYG;;AAEjC,UAAQiI,IAAR;AACE;AACA,SAAK,EAAL;AACE,aAAO,IAAI3D,KAAJ,CAAUQ,SAAS,CAACG,IAApB,EAA0BjF,GAA1B,EAA+BA,GAAG,GAAG,CAArC,EAAwC3H,IAAxC,EAA8CmQ,GAA9C,EAAmDhE,IAAnD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAOkE,WAAW,CAACxQ,MAAD,EAAS8H,GAAT,EAAc3H,IAAd,EAAoBmQ,GAApB,EAAyBhE,IAAzB,CAAlB;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACI,MAApB,EAA4BlF,GAA5B,EAAiCA,GAAG,GAAG,CAAvC,EAA0C3H,IAA1C,EAAgDmQ,GAAhD,EAAqDhE,IAArD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACK,GAApB,EAAyBnF,GAAzB,EAA8BA,GAAG,GAAG,CAApC,EAAuC3H,IAAvC,EAA6CmQ,GAA7C,EAAkDhE,IAAlD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACM,OAApB,EAA6BpF,GAA7B,EAAkCA,GAAG,GAAG,CAAxC,EAA2C3H,IAA3C,EAAiDmQ,GAAjD,EAAsDhE,IAAtD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACO,OAApB,EAA6BrF,GAA7B,EAAkCA,GAAG,GAAG,CAAxC,EAA2C3H,IAA3C,EAAiDmQ,GAAjD,EAAsDhE,IAAtD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,UAAI/L,IAAI,CAACgQ,UAAL,CAAgBzI,GAAG,GAAG,CAAtB,MAA6B,EAA7B,IAAmCvH,IAAI,CAACgQ,UAAL,CAAgBzI,GAAG,GAAG,CAAtB,MAA6B,EAApE,EAAwE;AACtE,eAAO,IAAIsE,KAAJ,CAAUQ,SAAS,CAACQ,MAApB,EAA4BtF,GAA5B,EAAiCA,GAAG,GAAG,CAAvC,EAA0C3H,IAA1C,EAAgDmQ,GAAhD,EAAqDhE,IAArD,CAAP;AACD;;AAED;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACS,KAApB,EAA2BvF,GAA3B,EAAgCA,GAAG,GAAG,CAAtC,EAAyC3H,IAAzC,EAA+CmQ,GAA/C,EAAoDhE,IAApD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACU,MAApB,EAA4BxF,GAA5B,EAAiCA,GAAG,GAAG,CAAvC,EAA0C3H,IAA1C,EAAgDmQ,GAAhD,EAAqDhE,IAArD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACW,EAApB,EAAwBzF,GAAxB,EAA6BA,GAAG,GAAG,CAAnC,EAAsC3H,IAAtC,EAA4CmQ,GAA5C,EAAiDhE,IAAjD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACY,SAApB,EAA+B1F,GAA/B,EAAoCA,GAAG,GAAG,CAA1C,EAA6C3H,IAA7C,EAAmDmQ,GAAnD,EAAwDhE,IAAxD,CAAP;AACF;;AAEA,SAAK,EAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACa,SAApB,EAA+B3F,GAA/B,EAAoCA,GAAG,GAAG,CAA1C,EAA6C3H,IAA7C,EAAmDmQ,GAAnD,EAAwDhE,IAAxD,CAAP;AACF;;AAEA,SAAK,GAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACc,OAApB,EAA6B5F,GAA7B,EAAkCA,GAAG,GAAG,CAAxC,EAA2C3H,IAA3C,EAAiDmQ,GAAjD,EAAsDhE,IAAtD,CAAP;AACF;;AAEA,SAAK,GAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACe,IAApB,EAA0B7F,GAA1B,EAA+BA,GAAG,GAAG,CAArC,EAAwC3H,IAAxC,EAA8CmQ,GAA9C,EAAmDhE,IAAnD,CAAP;AACF;;AAEA,SAAK,GAAL;AACE,aAAO,IAAIF,KAAJ,CAAUQ,SAAS,CAACgB,OAApB,EAA6B9F,GAA7B,EAAkCA,GAAG,GAAG,CAAxC,EAA2C3H,IAA3C,EAAiDmQ,GAAjD,EAAsDhE,IAAtD,CAAP;AACF;;AAEA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACA,SAAK,GAAL;AACE,aAAOmE,QAAQ,CAACzQ,MAAD,EAAS8H,GAAT,EAAc3H,IAAd,EAAoBmQ,GAApB,EAAyBhE,IAAzB,CAAf;AACF;;AAEA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACE,aAAOoE,UAAU,CAAC1Q,MAAD,EAAS8H,GAAT,EAAciI,IAAd,EAAoB5P,IAApB,EAA0BmQ,GAA1B,EAA+BhE,IAA/B,CAAjB;AACF;;AAEA,SAAK,EAAL;AACE,UAAI/L,IAAI,CAACgQ,UAAL,CAAgBzI,GAAG,GAAG,CAAtB,MAA6B,EAA7B,IAAmCvH,IAAI,CAACgQ,UAAL,CAAgBzI,GAAG,GAAG,CAAtB,MAA6B,EAApE,EAAwE;AACtE,eAAO6I,eAAe,CAAC3Q,MAAD,EAAS8H,GAAT,EAAc3H,IAAd,EAAoBmQ,GAApB,EAAyBhE,IAAzB,EAA+B6D,KAA/B,CAAtB;AACD;;AAED,aAAOS,UAAU,CAAC5Q,MAAD,EAAS8H,GAAT,EAAc3H,IAAd,EAAoBmQ,GAApB,EAAyBhE,IAAzB,CAAjB;AA7IJ;;AAgJA,QAAM1D,WAAW,CAAC5I,MAAD,EAAS8H,GAAT,EAAc+I,0BAA0B,CAACd,IAAD,CAAxC,CAAjB;AACD;AACD;AACA;AACA;;;AAGA,SAASc,0BAAT,CAAoCd,IAApC,EAA0C;AACxC,MAAIA,IAAI,GAAG,MAAP,IAAiBA,IAAI,KAAK,MAA1B,IAAoCA,IAAI,KAAK,MAA7C,IAAuDA,IAAI,KAAK,MAApE,EAA4E;AAC1E,WAAO,wCAAwC3S,MAAxC,CAA+C0S,aAAa,CAACC,IAAD,CAA5D,EAAoE,GAApE,CAAP;AACD;;AAED,MAAIA,IAAI,KAAK,EAAb,EAAiB;AACf;AACA,WAAO,iFAAP;AACD;;AAED,SAAO,yCAAyC3S,MAAzC,CAAgD0S,aAAa,CAACC,IAAD,CAA7D,EAAqE,GAArE,CAAP;AACD;AACD;AACA;AACA;AACA;;;AAGA,SAASM,uBAAT,CAAiC9P,IAAjC,EAAuCuQ,aAAvC,EAAsDX,KAAtD,EAA6D;AAC3D,MAAIC,UAAU,GAAG7P,IAAI,CAACnC,MAAtB;AACA,MAAI6B,QAAQ,GAAG6Q,aAAf;;AAEA,SAAO7Q,QAAQ,GAAGmQ,UAAlB,EAA8B;AAC5B,QAAIL,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAX,CAD4B,CACU;;AAEtC,QAAI8P,IAAI,KAAK,CAAT,IAAcA,IAAI,KAAK,EAAvB,IAA6BA,IAAI,KAAK,EAAtC,IAA4CA,IAAI,KAAK,MAAzD,EAAiE;AAC/D,QAAE9P,QAAF;AACD,KAFD,MAEO,IAAI8P,IAAI,KAAK,EAAb,EAAiB;AACtB;AACA,QAAE9P,QAAF;AACA,QAAEkQ,KAAK,CAAChQ,IAAR;AACAgQ,MAAAA,KAAK,CAACX,SAAN,GAAkBvP,QAAlB;AACD,KALM,MAKA,IAAI8P,IAAI,KAAK,EAAb,EAAiB;AACtB;AACA,UAAIxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAAtC,EAA0C;AACxCA,QAAAA,QAAQ,IAAI,CAAZ;AACD,OAFD,MAEO;AACL,UAAEA,QAAF;AACD;;AAED,QAAEkQ,KAAK,CAAChQ,IAAR;AACAgQ,MAAAA,KAAK,CAACX,SAAN,GAAkBvP,QAAlB;AACD,KAVM,MAUA;AACL;AACD;AACF;;AAED,SAAOA,QAAP;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASuQ,WAAT,CAAqBxQ,MAArB,EAA6BY,KAA7B,EAAoCT,IAApC,EAA0CmQ,GAA1C,EAA+ChE,IAA/C,EAAqD;AACnD,MAAI/L,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAIwP,IAAJ;AACA,MAAI9P,QAAQ,GAAGW,KAAf;;AAEA,KAAG;AACDmP,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;AACD,GAFD,QAES,CAAC+P,KAAK,CAACD,IAAD,CAAN,MAAkB;AAC3BA,EAAAA,IAAI,GAAG,MAAP,IAAiBA,IAAI,KAAK,MADjB,CAFT;;AAKA,SAAO,IAAI3D,KAAJ,CAAUQ,SAAS,CAACkB,OAApB,EAA6BlN,KAA7B,EAAoCX,QAApC,EAA8CE,IAA9C,EAAoDmQ,GAApD,EAAyDhE,IAAzD,EAA+D/L,IAAI,CAACuB,KAAL,CAAWlB,KAAK,GAAG,CAAnB,EAAsBX,QAAtB,CAA/D,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASyQ,UAAT,CAAoB1Q,MAApB,EAA4BY,KAA5B,EAAmCmQ,SAAnC,EAA8C5Q,IAA9C,EAAoDmQ,GAApD,EAAyDhE,IAAzD,EAA+D;AAC7D,MAAI/L,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAIwP,IAAI,GAAGgB,SAAX;AACA,MAAI9Q,QAAQ,GAAGW,KAAf;AACA,MAAIoQ,OAAO,GAAG,KAAd;;AAEA,MAAIjB,IAAI,KAAK,EAAb,EAAiB;AACf;AACAA,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;AACD;;AAED,MAAI8P,IAAI,KAAK,EAAb,EAAiB;AACf;AACAA,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;;AAEA,QAAI8P,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAA1B,EAA8B;AAC5B,YAAMnH,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,6CAA6C7C,MAA7C,CAAoD0S,aAAa,CAACC,IAAD,CAAjE,EAAyE,GAAzE,CAAnB,CAAjB;AACD;AACF,GAPD,MAOO;AACL9P,IAAAA,QAAQ,GAAGgR,UAAU,CAACjR,MAAD,EAASC,QAAT,EAAmB8P,IAAnB,CAArB;AACAA,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAP;AACD;;AAED,MAAI8P,IAAI,KAAK,EAAb,EAAiB;AACf;AACAiB,IAAAA,OAAO,GAAG,IAAV;AACAjB,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;AACAA,IAAAA,QAAQ,GAAGgR,UAAU,CAACjR,MAAD,EAASC,QAAT,EAAmB8P,IAAnB,CAArB;AACAA,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAP;AACD;;AAED,MAAI8P,IAAI,KAAK,EAAT,IAAeA,IAAI,KAAK,GAA5B,EAAiC;AAC/B;AACAiB,IAAAA,OAAO,GAAG,IAAV;AACAjB,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;;AAEA,QAAI8P,IAAI,KAAK,EAAT,IAAeA,IAAI,KAAK,EAA5B,EAAgC;AAC9B;AACAA,MAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;AACD;;AAEDA,IAAAA,QAAQ,GAAGgR,UAAU,CAACjR,MAAD,EAASC,QAAT,EAAmB8P,IAAnB,CAArB;AACAA,IAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAP;AACD,GA3C4D,CA2C3D;;;AAGF,MAAI8P,IAAI,KAAK,EAAT,IAAemB,WAAW,CAACnB,IAAD,CAA9B,EAAsC;AACpC,UAAMnH,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,2CAA2C7C,MAA3C,CAAkD0S,aAAa,CAACC,IAAD,CAA/D,EAAuE,GAAvE,CAAnB,CAAjB;AACD;;AAED,SAAO,IAAI3D,KAAJ,CAAU4E,OAAO,GAAGpE,SAAS,CAAChD,KAAb,GAAqBgD,SAAS,CAACjD,GAAhD,EAAqD/I,KAArD,EAA4DX,QAA5D,EAAsEE,IAAtE,EAA4EmQ,GAA5E,EAAiFhE,IAAjF,EAAuF/L,IAAI,CAACuB,KAAL,CAAWlB,KAAX,EAAkBX,QAAlB,CAAvF,CAAP;AACD;AACD;AACA;AACA;;;AAGA,SAASgR,UAAT,CAAoBjR,MAApB,EAA4BY,KAA5B,EAAmCmQ,SAAnC,EAA8C;AAC5C,MAAIxQ,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAIN,QAAQ,GAAGW,KAAf;AACA,MAAImP,IAAI,GAAGgB,SAAX;;AAEA,MAAIhB,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAA1B,EAA8B;AAC5B;AACA,OAAG;AACDA,MAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgB,EAAEtQ,QAAlB,CAAP;AACD,KAFD,QAES8P,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAF/B,EAF4B,CAIQ;;;AAGpC,WAAO9P,QAAP;AACD;;AAED,QAAM2I,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,2CAA2C7C,MAA3C,CAAkD0S,aAAa,CAACC,IAAD,CAA/D,EAAuE,GAAvE,CAAnB,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASa,UAAT,CAAoB5Q,MAApB,EAA4BY,KAA5B,EAAmCT,IAAnC,EAAyCmQ,GAAzC,EAA8ChE,IAA9C,EAAoD;AAClD,MAAI/L,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAIN,QAAQ,GAAGW,KAAK,GAAG,CAAvB;AACA,MAAIuQ,UAAU,GAAGlR,QAAjB;AACA,MAAI8P,IAAI,GAAG,CAAX;AACA,MAAIjT,KAAK,GAAG,EAAZ;;AAEA,SAAOmD,QAAQ,GAAGM,IAAI,CAACnC,MAAhB,IAA0B,CAAC4R,KAAK,CAACD,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAR,CAAhC,IAAsE;AAC7E8P,EAAAA,IAAI,KAAK,MADF,IACYA,IAAI,KAAK,MAD5B,EACoC;AAClC;AACA,QAAIA,IAAI,KAAK,EAAb,EAAiB;AACfjT,MAAAA,KAAK,IAAIyD,IAAI,CAACuB,KAAL,CAAWqP,UAAX,EAAuBlR,QAAvB,CAAT;AACA,aAAO,IAAImM,KAAJ,CAAUQ,SAAS,CAAC/C,MAApB,EAA4BjJ,KAA5B,EAAmCX,QAAQ,GAAG,CAA9C,EAAiDE,IAAjD,EAAuDmQ,GAAvD,EAA4DhE,IAA5D,EAAkExP,KAAlE,CAAP;AACD,KALiC,CAKhC;;;AAGF,QAAIiT,IAAI,GAAG,MAAP,IAAiBA,IAAI,KAAK,MAA9B,EAAsC;AACpC,YAAMnH,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,oCAAoC7C,MAApC,CAA2C0S,aAAa,CAACC,IAAD,CAAxD,EAAgE,GAAhE,CAAnB,CAAjB;AACD;;AAED,MAAE9P,QAAF;;AAEA,QAAI8P,IAAI,KAAK,EAAb,EAAiB;AACf;AACAjT,MAAAA,KAAK,IAAIyD,IAAI,CAACuB,KAAL,CAAWqP,UAAX,EAAuBlR,QAAQ,GAAG,CAAlC,CAAT;AACA8P,MAAAA,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAP;;AAEA,cAAQ8P,IAAR;AACE,aAAK,EAAL;AACEjT,UAAAA,KAAK,IAAI,GAAT;AACA;;AAEF,aAAK,EAAL;AACEA,UAAAA,KAAK,IAAI,GAAT;AACA;;AAEF,aAAK,EAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,EAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,GAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,GAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,GAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,GAAL;AACEA,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAK,GAAL;AACE;AACE;AACA,gBAAIsU,QAAQ,GAAGC,WAAW,CAAC9Q,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,CAAD,EAAgCM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,CAAhC,EAA+DM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,CAA/D,EAA8FM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,CAA9F,CAA1B;;AAEA,gBAAImR,QAAQ,GAAG,CAAf,EAAkB;AAChB,kBAAIE,eAAe,GAAG/Q,IAAI,CAACuB,KAAL,CAAW7B,QAAQ,GAAG,CAAtB,EAAyBA,QAAQ,GAAG,CAApC,CAAtB;AACA,oBAAM2I,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,yCAAyC7C,MAAzC,CAAgDkU,eAAhD,EAAiE,GAAjE,CAAnB,CAAjB;AACD;;AAEDxU,YAAAA,KAAK,IAAIQ,MAAM,CAAC2S,YAAP,CAAoBmB,QAApB,CAAT;AACAnR,YAAAA,QAAQ,IAAI,CAAZ;AACA;AACD;;AAEH;AACE,gBAAM2I,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,wCAAwC7C,MAAxC,CAA+CE,MAAM,CAAC2S,YAAP,CAAoBF,IAApB,CAA/C,EAA0E,GAA1E,CAAnB,CAAjB;AAjDJ;;AAoDA,QAAE9P,QAAF;AACAkR,MAAAA,UAAU,GAAGlR,QAAb;AACD;AACF;;AAED,QAAM2I,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,sBAAnB,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS0Q,eAAT,CAAyB3Q,MAAzB,EAAiCY,KAAjC,EAAwCT,IAAxC,EAA8CmQ,GAA9C,EAAmDhE,IAAnD,EAAyD6D,KAAzD,EAAgE;AAC9D,MAAI5P,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAIN,QAAQ,GAAGW,KAAK,GAAG,CAAvB;AACA,MAAIuQ,UAAU,GAAGlR,QAAjB;AACA,MAAI8P,IAAI,GAAG,CAAX;AACA,MAAIwB,QAAQ,GAAG,EAAf;;AAEA,SAAOtR,QAAQ,GAAGM,IAAI,CAACnC,MAAhB,IAA0B,CAAC4R,KAAK,CAACD,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAR,CAAvC,EAA2E;AACzE;AACA,QAAI8P,IAAI,KAAK,EAAT,IAAexP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAAjD,IAAuDM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAA7F,EAAiG;AAC/FsR,MAAAA,QAAQ,IAAIhR,IAAI,CAACuB,KAAL,CAAWqP,UAAX,EAAuBlR,QAAvB,CAAZ;AACA,aAAO,IAAImM,KAAJ,CAAUQ,SAAS,CAACiB,YAApB,EAAkCjN,KAAlC,EAAyCX,QAAQ,GAAG,CAApD,EAAuDE,IAAvD,EAA6DmQ,GAA7D,EAAkEhE,IAAlE,EAAwEqC,sBAAsB,CAAC4C,QAAD,CAA9F,CAAP;AACD,KALwE,CAKvE;;;AAGF,QAAIxB,IAAI,GAAG,MAAP,IAAiBA,IAAI,KAAK,MAA1B,IAAoCA,IAAI,KAAK,MAA7C,IAAuDA,IAAI,KAAK,MAApE,EAA4E;AAC1E,YAAMnH,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,oCAAoC7C,MAApC,CAA2C0S,aAAa,CAACC,IAAD,CAAxD,EAAgE,GAAhE,CAAnB,CAAjB;AACD;;AAED,QAAIA,IAAI,KAAK,EAAb,EAAiB;AACf;AACA,QAAE9P,QAAF;AACA,QAAEkQ,KAAK,CAAChQ,IAAR;AACAgQ,MAAAA,KAAK,CAACX,SAAN,GAAkBvP,QAAlB;AACD,KALD,MAKO,IAAI8P,IAAI,KAAK,EAAb,EAAiB;AACtB;AACA,UAAIxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAAtC,EAA0C;AACxCA,QAAAA,QAAQ,IAAI,CAAZ;AACD,OAFD,MAEO;AACL,UAAEA,QAAF;AACD;;AAED,QAAEkQ,KAAK,CAAChQ,IAAR;AACAgQ,MAAAA,KAAK,CAACX,SAAN,GAAkBvP,QAAlB;AACD,KAVM,MAUA,KAAK;AACZ8P,IAAAA,IAAI,KAAK,EAAT,IAAexP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAAjD,IAAuDM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAAzF,IAA+FM,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAQ,GAAG,CAA3B,MAAkC,EAD1H,EAC8H;AACnIsR,MAAAA,QAAQ,IAAIhR,IAAI,CAACuB,KAAL,CAAWqP,UAAX,EAAuBlR,QAAvB,IAAmC,KAA/C;AACAA,MAAAA,QAAQ,IAAI,CAAZ;AACAkR,MAAAA,UAAU,GAAGlR,QAAb;AACD,KALM,MAKA;AACL,QAAEA,QAAF;AACD;AACF;;AAED,QAAM2I,WAAW,CAAC5I,MAAD,EAASC,QAAT,EAAmB,sBAAnB,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASoR,WAAT,CAAqBxW,CAArB,EAAwBgB,CAAxB,EAA2BE,CAA3B,EAA8Bd,CAA9B,EAAiC;AAC/B,SAAOuW,QAAQ,CAAC3W,CAAD,CAAR,IAAe,EAAf,GAAoB2W,QAAQ,CAAC3V,CAAD,CAAR,IAAe,CAAnC,GAAuC2V,QAAQ,CAACzV,CAAD,CAAR,IAAe,CAAtD,GAA0DyV,QAAQ,CAACvW,CAAD,CAAzE;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASuW,QAAT,CAAkB3W,CAAlB,EAAqB;AACnB,SAAOA,CAAC,IAAI,EAAL,IAAWA,CAAC,IAAI,EAAhB,GAAqBA,CAAC,GAAG,EAAzB,CAA4B;AAA5B,IACLA,CAAC,IAAI,EAAL,IAAWA,CAAC,IAAI,EAAhB,GAAqBA,CAAC,GAAG,EAAzB,CAA4B;AAA5B,IACAA,CAAC,IAAI,EAAL,IAAWA,CAAC,IAAI,GAAhB,GAAsBA,CAAC,GAAG,EAA1B,CAA6B;AAA7B,IACA,CAAC,CAHH;AAID;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS4V,QAAT,CAAkBzQ,MAAlB,EAA0BY,KAA1B,EAAiCT,IAAjC,EAAuCmQ,GAAvC,EAA4ChE,IAA5C,EAAkD;AAChD,MAAI/L,IAAI,GAAGP,MAAM,CAACO,IAAlB;AACA,MAAI6P,UAAU,GAAG7P,IAAI,CAACnC,MAAtB;AACA,MAAI6B,QAAQ,GAAGW,KAAK,GAAG,CAAvB;AACA,MAAImP,IAAI,GAAG,CAAX;;AAEA,SAAO9P,QAAQ,KAAKmQ,UAAb,IAA2B,CAACJ,KAAK,CAACD,IAAI,GAAGxP,IAAI,CAACgQ,UAAL,CAAgBtQ,QAAhB,CAAR,CAAjC,KAAwE8P,IAAI,KAAK,EAAT,IAAe;AAC9FA,EAAAA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EADyD,IACnD;AAC5BA,EAAAA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAFyD,IAEnD;AAC5BA,EAAAA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,GAHf,CAAP,CAG2B;AAH3B,IAIE;AACA,MAAE9P,QAAF;AACD;;AAED,SAAO,IAAImM,KAAJ,CAAUQ,SAAS,CAAC5D,IAApB,EAA0BpI,KAA1B,EAAiCX,QAAjC,EAA2CE,IAA3C,EAAiDmQ,GAAjD,EAAsDhE,IAAtD,EAA4D/L,IAAI,CAACuB,KAAL,CAAWlB,KAAX,EAAkBX,QAAlB,CAA5D,CAAP;AACD,C,CAAC;;;AAGF,SAASiR,WAAT,CAAqBnB,IAArB,EAA2B;AACzB,SAAOA,IAAI,KAAK,EAAT,IAAeA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAArC,IAA2CA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,GAAxE;AACD;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,SAAS0B,KAAT,CAAezR,MAAf,EAAuB0R,OAAvB,EAAgC;AAC9B,MAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAW5R,MAAX,EAAmB0R,OAAnB,CAAb;AACA,SAAOC,MAAM,CAACE,aAAP,EAAP;AACD;;AAED,IAAID,MAAM,GAAG,aAAa,YAAY;AACpC,WAASA,MAAT,CAAgB5R,MAAhB,EAAwB0R,OAAxB,EAAiC;AAC/B,QAAII,SAAS,GAAG,OAAO9R,MAAP,KAAkB,QAAlB,GAA6B,IAAI2M,MAAJ,CAAW3M,MAAX,CAA7B,GAAkDA,MAAlE;AACA8R,IAAAA,SAAS,YAAYnF,MAArB,IAA+BtN,SAAS,CAAC,CAAD,EAAI,kCAAkCjC,MAAlC,CAAyCP,OAAO,CAACiV,SAAD,CAAhD,EAA6D,GAA7D,CAAJ,CAAxC;AACA,SAAKC,MAAL,GAAc,IAAI3C,KAAJ,CAAU0C,SAAV,CAAd;AACA,SAAKE,QAAL,GAAgBN,OAAhB;AACD;AACD;AACF;AACA;;;AAGE,MAAIvF,MAAM,GAAGyF,MAAM,CAAClV,SAApB;;AAEAyP,EAAAA,MAAM,CAAC8F,SAAP,GAAmB,SAASA,SAAT,GAAqB;AACtC,QAAI1C,KAAK,GAAG,KAAK2C,WAAL,CAAiBtF,SAAS,CAAC5D,IAA3B,CAAZ;AACA,WAAO;AACLqD,MAAAA,IAAI,EAAEvD,IAAI,CAACE,IADN;AAELlM,MAAAA,KAAK,EAAEyS,KAAK,CAACzS,KAFR;AAGL0K,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,KAAP;AAKD,GAPD,CAOE;;AAEF;AACF;AACA;AAXE;;AAcApD,EAAAA,MAAM,CAAC0F,aAAP,GAAuB,SAASA,aAAT,GAAyB;AAC9C,QAAIjR,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,WAAO;AACLlD,MAAAA,IAAI,EAAEvD,IAAI,CAACG,QADN;AAELkJ,MAAAA,WAAW,EAAE,KAAKC,IAAL,CAAUxF,SAAS,CAACC,GAApB,EAAyB,KAAKwF,eAA9B,EAA+CzF,SAAS,CAACE,GAAzD,CAFR;AAGLtF,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBE;;AAoBAuL,EAAAA,MAAM,CAACkG,eAAP,GAAyB,SAASA,eAAT,GAA2B;AAClD,QAAI,KAAKC,IAAL,CAAU1F,SAAS,CAAC5D,IAApB,CAAJ,EAA+B;AAC7B,cAAQ,KAAK+I,MAAL,CAAYxC,KAAZ,CAAkBzS,KAA1B;AACE,aAAK,OAAL;AACA,aAAK,UAAL;AACA,aAAK,cAAL;AACE,iBAAO,KAAKyV,wBAAL,EAAP;;AAEF,aAAK,UAAL;AACE,iBAAO,KAAKC,uBAAL,EAAP;;AAEF,aAAK,QAAL;AACA,aAAK,QAAL;AACA,aAAK,MAAL;AACA,aAAK,WAAL;AACA,aAAK,OAAL;AACA,aAAK,MAAL;AACA,aAAK,OAAL;AACA,aAAK,WAAL;AACE,iBAAO,KAAKC,yBAAL,EAAP;;AAEF,aAAK,QAAL;AACE,iBAAO,KAAKC,wBAAL,EAAP;AApBJ;AAsBD,KAvBD,MAuBO,IAAI,KAAKJ,IAAL,CAAU1F,SAAS,CAACc,OAApB,CAAJ,EAAkC;AACvC,aAAO,KAAK6E,wBAAL,EAAP;AACD,KAFM,MAEA,IAAI,KAAKI,eAAL,EAAJ,EAA4B;AACjC,aAAO,KAAKF,yBAAL,EAAP;AACD;;AAED,UAAM,KAAKG,UAAL,EAAN;AACD,GA/BD,CA+BE;;AAEF;AACF;AACA;AACA;AACA;AArCE;;AAwCAzG,EAAAA,MAAM,CAACoG,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAI3R,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;;AAEA,QAAI,KAAK+C,IAAL,CAAU1F,SAAS,CAACc,OAApB,CAAJ,EAAkC;AAChC,aAAO;AACLrB,QAAAA,IAAI,EAAEvD,IAAI,CAACI,oBADN;AAEL2J,QAAAA,SAAS,EAAE,OAFN;AAGL1V,QAAAA,IAAI,EAAEd,SAHD;AAILyW,QAAAA,mBAAmB,EAAE,EAJhB;AAKLC,QAAAA,UAAU,EAAE,EALP;AAMLC,QAAAA,YAAY,EAAE,KAAKC,iBAAL,EANT;AAOLzL,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,OAAP;AASD;;AAED,QAAIiS,SAAS,GAAG,KAAKK,kBAAL,EAAhB;AACA,QAAI/V,IAAJ;;AAEA,QAAI,KAAKmV,IAAL,CAAU1F,SAAS,CAAC5D,IAApB,CAAJ,EAA+B;AAC7B7L,MAAAA,IAAI,GAAG,KAAK8U,SAAL,EAAP;AACD;;AAED,WAAO;AACL5F,MAAAA,IAAI,EAAEvD,IAAI,CAACI,oBADN;AAEL2J,MAAAA,SAAS,EAAEA,SAFN;AAGL1V,MAAAA,IAAI,EAAEA,IAHD;AAIL2V,MAAAA,mBAAmB,EAAE,KAAKK,wBAAL,EAJhB;AAKLJ,MAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;AAMLJ,MAAAA,YAAY,EAAE,KAAKC,iBAAL,EANT;AAOLzL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AAlCE;;AAqCAuL,EAAAA,MAAM,CAAC+G,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAIG,cAAc,GAAG,KAAKnB,WAAL,CAAiBtF,SAAS,CAAC5D,IAA3B,CAArB;;AAEA,YAAQqK,cAAc,CAACvW,KAAvB;AACE,WAAK,OAAL;AACE,eAAO,OAAP;;AAEF,WAAK,UAAL;AACE,eAAO,UAAP;;AAEF,WAAK,cAAL;AACE,eAAO,cAAP;AARJ;;AAWA,UAAM,KAAK8V,UAAL,CAAgBS,cAAhB,CAAN;AACD;AACD;AACF;AACA;AAlBE;;AAqBAlH,EAAAA,MAAM,CAACgH,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,WAAO,KAAKG,YAAL,CAAkB1G,SAAS,CAACM,OAA5B,EAAqC,KAAKqG,uBAA1C,EAAmE3G,SAAS,CAACO,OAA7E,CAAP;AACD;AACD;AACF;AACA;AALE;;AAQAhB,EAAAA,MAAM,CAACoH,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;AAClE,QAAI3S,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,WAAO;AACLlD,MAAAA,IAAI,EAAEvD,IAAI,CAACK,mBADN;AAELqK,MAAAA,QAAQ,EAAE,KAAKC,aAAL,EAFL;AAGLC,MAAAA,IAAI,GAAG,KAAKxB,WAAL,CAAiBtF,SAAS,CAACS,KAA3B,GAAmC,KAAKsG,kBAAL,EAAtC,CAHC;AAILC,MAAAA,YAAY,EAAE,KAAKC,mBAAL,CAAyBjH,SAAS,CAACU,MAAnC,IAA6C,KAAKwG,iBAAL,CAAuB,IAAvB,CAA7C,GAA4EzX,SAJrF;AAKL0W,MAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,IAArB,CALP;AAML5L,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AAbE;;AAgBAuL,EAAAA,MAAM,CAACsH,aAAP,GAAuB,SAASA,aAAT,GAAyB;AAC9C,QAAI7S,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAK2C,WAAL,CAAiBtF,SAAS,CAACI,MAA3B;AACA,WAAO;AACLX,MAAAA,IAAI,EAAEvD,IAAI,CAACY,QADN;AAELvM,MAAAA,IAAI,EAAE,KAAK8U,SAAL,EAFD;AAGLzK,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD;AACD;AACF;AACA;AAXE;;AAcAuL,EAAAA,MAAM,CAAC8G,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;AACtD,QAAIrS,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,WAAO;AACLlD,MAAAA,IAAI,EAAEvD,IAAI,CAACM,aADN;AAEL2K,MAAAA,UAAU,EAAE,KAAK3B,IAAL,CAAUxF,SAAS,CAACc,OAApB,EAA6B,KAAKsG,cAAlC,EAAkDpH,SAAS,CAACgB,OAA5D,CAFP;AAGLpG,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD;AACD;AACF;AACA;AACA;AACA;AACA;AAbE;;AAgBAuL,EAAAA,MAAM,CAAC6H,cAAP,GAAwB,SAASA,cAAT,GAA0B;AAChD,WAAO,KAAK1B,IAAL,CAAU1F,SAAS,CAACQ,MAApB,IAA8B,KAAK6G,aAAL,EAA9B,GAAqD,KAAKC,UAAL,EAA5D;AACD;AACD;AACF;AACA;AACA;AACA;AAPE;;AAUA/H,EAAAA,MAAM,CAAC+H,UAAP,GAAoB,SAASA,UAAT,GAAsB;AACxC,QAAItT,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI4E,WAAW,GAAG,KAAKlC,SAAL,EAAlB;AACA,QAAImC,KAAJ;AACA,QAAIjX,IAAJ;;AAEA,QAAI,KAAK0W,mBAAL,CAAyBjH,SAAS,CAACS,KAAnC,CAAJ,EAA+C;AAC7C+G,MAAAA,KAAK,GAAGD,WAAR;AACAhX,MAAAA,IAAI,GAAG,KAAK8U,SAAL,EAAP;AACD,KAHD,MAGO;AACL9U,MAAAA,IAAI,GAAGgX,WAAP;AACD;;AAED,WAAO;AACL9H,MAAAA,IAAI,EAAEvD,IAAI,CAACO,KADN;AAEL+K,MAAAA,KAAK,EAAEA,KAFF;AAGLjX,MAAAA,IAAI,EAAEA,IAHD;AAIL0H,MAAAA,SAAS,EAAE,KAAKwP,cAAL,CAAoB,KAApB,CAJN;AAKLtB,MAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;AAMLJ,MAAAA,YAAY,EAAE,KAAKV,IAAL,CAAU1F,SAAS,CAACc,OAApB,IAA+B,KAAKuF,iBAAL,EAA/B,GAA0D5W,SANnE;AAOLmL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AAzBE;;AA4BAuL,EAAAA,MAAM,CAACkI,cAAP,GAAwB,SAASA,cAAT,CAAwBC,OAAxB,EAAiC;AACvD,QAAIC,IAAI,GAAGD,OAAO,GAAG,KAAKE,kBAAR,GAA6B,KAAKC,aAApD;AACA,WAAO,KAAKnB,YAAL,CAAkB1G,SAAS,CAACM,OAA5B,EAAqCqH,IAArC,EAA2C3H,SAAS,CAACO,OAArD,CAAP;AACD;AACD;AACF;AACA;AANE;;AASAhB,EAAAA,MAAM,CAACsI,aAAP,GAAuB,SAASA,aAAT,GAAyB;AAC9C,QAAI7T,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAIpS,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,SAAKC,WAAL,CAAiBtF,SAAS,CAACS,KAA3B;AACA,WAAO;AACLhB,MAAAA,IAAI,EAAEvD,IAAI,CAACQ,QADN;AAELnM,MAAAA,IAAI,EAAEA,IAFD;AAGLL,MAAAA,KAAK,EAAE,KAAKgX,iBAAL,CAAuB,KAAvB,CAHF;AAILtM,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD,GAVD;;AAYAuL,EAAAA,MAAM,CAACqI,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAI5T,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,WAAO;AACLlD,MAAAA,IAAI,EAAEvD,IAAI,CAACQ,QADN;AAELnM,MAAAA,IAAI,EAAE,KAAK8U,SAAL,EAFD;AAGLnV,MAAAA,KAAK,GAAG,KAAKoV,WAAL,CAAiBtF,SAAS,CAACS,KAA3B,GAAmC,KAAKyG,iBAAL,CAAuB,IAAvB,CAAtC,CAHA;AAILtM,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD,GARD,CAQE;;AAEF;AACF;AACA;AACA;AACA;AACA;AACA;AAhBE;;AAmBAuL,EAAAA,MAAM,CAAC8H,aAAP,GAAuB,SAASA,aAAT,GAAyB;AAC9C,QAAIrT,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAK2C,WAAL,CAAiBtF,SAAS,CAACQ,MAA3B;AACA,QAAIsH,gBAAgB,GAAG,KAAKC,qBAAL,CAA2B,IAA3B,CAAvB;;AAEA,QAAI,CAACD,gBAAD,IAAqB,KAAKpC,IAAL,CAAU1F,SAAS,CAAC5D,IAApB,CAAzB,EAAoD;AAClD,aAAO;AACLqD,QAAAA,IAAI,EAAEvD,IAAI,CAACS,eADN;AAELpM,QAAAA,IAAI,EAAE,KAAKyX,iBAAL,EAFD;AAGL7B,QAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAHP;AAIL5L,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,OAAP;AAMD;;AAED,WAAO;AACLyL,MAAAA,IAAI,EAAEvD,IAAI,CAACU,eADN;AAELqL,MAAAA,aAAa,EAAEH,gBAAgB,GAAG,KAAKI,cAAL,EAAH,GAA2BzY,SAFrD;AAGL0W,MAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAHP;AAILJ,MAAAA,YAAY,EAAE,KAAKC,iBAAL,EAJT;AAKLzL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AACA;AACA;AA3BE;;AA8BAuL,EAAAA,MAAM,CAACqG,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;AAClE,QAAIuC,cAAJ;;AAEA,QAAInU,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,UAAnB,EAJkE,CAIlC;AAChC;AACA;;AAEA,QAAI,CAAC,CAACD,cAAc,GAAG,KAAK/C,QAAvB,MAAqC,IAArC,IAA6C+C,cAAc,KAAK,KAAK,CAArE,GAAyE,KAAK,CAA9E,GAAkFA,cAAc,CAACE,6BAAlG,MAAqI,IAAzI,EAA+I;AAC7I,aAAO;AACL5I,QAAAA,IAAI,EAAEvD,IAAI,CAACW,mBADN;AAELtM,QAAAA,IAAI,EAAE,KAAKyX,iBAAL,EAFD;AAGL9B,QAAAA,mBAAmB,EAAE,KAAKK,wBAAL,EAHhB;AAIL0B,QAAAA,aAAa,GAAG,KAAKG,aAAL,CAAmB,IAAnB,GAA0B,KAAKF,cAAL,EAA7B,CAJR;AAKL/B,QAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;AAMLJ,QAAAA,YAAY,EAAE,KAAKC,iBAAL,EANT;AAOLzL,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,OAAP;AASD;;AAED,WAAO;AACLyL,MAAAA,IAAI,EAAEvD,IAAI,CAACW,mBADN;AAELtM,MAAAA,IAAI,EAAE,KAAKyX,iBAAL,EAFD;AAGLC,MAAAA,aAAa,GAAG,KAAKG,aAAL,CAAmB,IAAnB,GAA0B,KAAKF,cAAL,EAA7B,CAHR;AAIL/B,MAAAA,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAJP;AAKLJ,MAAAA,YAAY,EAAE,KAAKC,iBAAL,EALT;AAMLzL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AA/BE;;AAkCAuL,EAAAA,MAAM,CAACyI,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;AACtD,QAAI,KAAK7C,MAAL,CAAYxC,KAAZ,CAAkBzS,KAAlB,KAA4B,IAAhC,EAAsC;AACpC,YAAM,KAAK8V,UAAL,EAAN;AACD;;AAED,WAAO,KAAKX,SAAL,EAAP;AACD,GAND,CAME;;AAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBE;;AA4BA9F,EAAAA,MAAM,CAAC2H,iBAAP,GAA2B,SAASA,iBAAT,CAA2BQ,OAA3B,EAAoC;AAC7D,QAAI/E,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,YAAQA,KAAK,CAAClD,IAAd;AACE,WAAKO,SAAS,CAACY,SAAf;AACE,eAAO,KAAK0H,SAAL,CAAeZ,OAAf,CAAP;;AAEF,WAAK1H,SAAS,CAACc,OAAf;AACE,eAAO,KAAKyH,WAAL,CAAiBb,OAAjB,CAAP;;AAEF,WAAK1H,SAAS,CAACjD,GAAf;AACE,aAAKoI,MAAL,CAAYtC,OAAZ;;AAEA,eAAO;AACLpD,UAAAA,IAAI,EAAEvD,IAAI,CAACa,GADN;AAEL7M,UAAAA,KAAK,EAAEyS,KAAK,CAACzS,KAFR;AAGL0K,UAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,SAAP;;AAMF,WAAK3C,SAAS,CAAChD,KAAf;AACE,aAAKmI,MAAL,CAAYtC,OAAZ;;AAEA,eAAO;AACLpD,UAAAA,IAAI,EAAEvD,IAAI,CAACc,KADN;AAEL9M,UAAAA,KAAK,EAAEyS,KAAK,CAACzS,KAFR;AAGL0K,UAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,SAAP;;AAMF,WAAK3C,SAAS,CAAC/C,MAAf;AACA,WAAK+C,SAAS,CAACiB,YAAf;AACE,eAAO,KAAKuH,kBAAL,EAAP;;AAEF,WAAKxI,SAAS,CAAC5D,IAAf;AACE,aAAK+I,MAAL,CAAYtC,OAAZ;;AAEA,gBAAQF,KAAK,CAACzS,KAAd;AACE,eAAK,MAAL;AACE,mBAAO;AACLuP,cAAAA,IAAI,EAAEvD,IAAI,CAACgB,OADN;AAELhN,cAAAA,KAAK,EAAE,IAFF;AAGL0K,cAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,aAAP;;AAMF,eAAK,OAAL;AACE,mBAAO;AACLlD,cAAAA,IAAI,EAAEvD,IAAI,CAACgB,OADN;AAELhN,cAAAA,KAAK,EAAE,KAFF;AAGL0K,cAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,aAAP;;AAMF,eAAK,MAAL;AACE,mBAAO;AACLlD,cAAAA,IAAI,EAAEvD,IAAI,CAACiB,IADN;AAELvC,cAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAFA,aAAP;;AAKF;AACE,mBAAO;AACLlD,cAAAA,IAAI,EAAEvD,IAAI,CAACkB,IADN;AAELlN,cAAAA,KAAK,EAAEyS,KAAK,CAACzS,KAFR;AAGL0K,cAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAHA,aAAP;AAtBJ;;AA6BF,WAAK3C,SAAS,CAACI,MAAf;AACE,YAAI,CAACsH,OAAL,EAAc;AACZ,iBAAO,KAAKb,aAAL,EAAP;AACD;;AAED;AAlEJ;;AAqEA,UAAM,KAAKb,UAAL,EAAN;AACD,GAzED;;AA2EAzG,EAAAA,MAAM,CAACiJ,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAI7F,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,SAAKwC,MAAL,CAAYtC,OAAZ;;AAEA,WAAO;AACLpD,MAAAA,IAAI,EAAEvD,IAAI,CAACe,MADN;AAEL/M,MAAAA,KAAK,EAAEyS,KAAK,CAACzS,KAFR;AAGLuY,MAAAA,KAAK,EAAE9F,KAAK,CAAClD,IAAN,KAAeO,SAAS,CAACiB,YAH3B;AAILrG,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS+H,KAAT;AAJA,KAAP;AAMD;AACD;AACF;AACA;AACA;AACA;AAhBE;;AAmBApD,EAAAA,MAAM,CAAC+I,SAAP,GAAmB,SAASA,SAAT,CAAmBZ,OAAnB,EAA4B;AAC7C,QAAIlN,KAAK,GAAG,IAAZ;;AAEA,QAAIxG,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;;AAEA,QAAIgF,IAAI,GAAG,SAASA,IAAT,GAAgB;AACzB,aAAOnN,KAAK,CAAC0M,iBAAN,CAAwBQ,OAAxB,CAAP;AACD,KAFD;;AAIA,WAAO;AACLjI,MAAAA,IAAI,EAAEvD,IAAI,CAACmB,IADN;AAELqL,MAAAA,MAAM,EAAE,KAAKC,GAAL,CAAS3I,SAAS,CAACY,SAAnB,EAA8B+G,IAA9B,EAAoC3H,SAAS,CAACa,SAA9C,CAFH;AAGLjG,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD;AACD;AACF;AACA;AACA;AACA;AAnBE;;AAsBAuL,EAAAA,MAAM,CAACgJ,WAAP,GAAqB,SAASA,WAAT,CAAqBb,OAArB,EAA8B;AACjD,QAAIkB,MAAM,GAAG,IAAb;;AAEA,QAAI5U,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;;AAEA,QAAIgF,IAAI,GAAG,SAASA,IAAT,GAAgB;AACzB,aAAOiB,MAAM,CAACC,gBAAP,CAAwBnB,OAAxB,CAAP;AACD,KAFD;;AAIA,WAAO;AACLjI,MAAAA,IAAI,EAAEvD,IAAI,CAACoB,MADN;AAELwL,MAAAA,MAAM,EAAE,KAAKH,GAAL,CAAS3I,SAAS,CAACc,OAAnB,EAA4B6G,IAA5B,EAAkC3H,SAAS,CAACgB,OAA5C,CAFH;AAGLpG,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD;AACD;AACF;AACA;AAjBE;;AAoBAuL,EAAAA,MAAM,CAACsJ,gBAAP,GAA0B,SAASA,gBAAT,CAA0BnB,OAA1B,EAAmC;AAC3D,QAAI1T,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAIpS,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,SAAKC,WAAL,CAAiBtF,SAAS,CAACS,KAA3B;AACA,WAAO;AACLhB,MAAAA,IAAI,EAAEvD,IAAI,CAACqB,YADN;AAELhN,MAAAA,IAAI,EAAEA,IAFD;AAGLL,MAAAA,KAAK,EAAE,KAAKgX,iBAAL,CAAuBQ,OAAvB,CAHF;AAIL9M,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD,GAVD,CAUE;;AAEF;AACF;AACA;AAdE;;AAiBAuL,EAAAA,MAAM,CAACiH,eAAP,GAAyB,SAASA,eAAT,CAAyBkB,OAAzB,EAAkC;AACzD,QAAIvB,UAAU,GAAG,EAAjB;;AAEA,WAAO,KAAKT,IAAL,CAAU1F,SAAS,CAACW,EAApB,CAAP,EAAgC;AAC9BwF,MAAAA,UAAU,CAAC9T,IAAX,CAAgB,KAAK0W,cAAL,CAAoBrB,OAApB,CAAhB;AACD;;AAED,WAAOvB,UAAP;AACD;AACD;AACF;AACA;AAXE;;AAcA5G,EAAAA,MAAM,CAACwJ,cAAP,GAAwB,SAASA,cAAT,CAAwBrB,OAAxB,EAAiC;AACvD,QAAI1T,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAK2C,WAAL,CAAiBtF,SAAS,CAACW,EAA3B;AACA,WAAO;AACLlB,MAAAA,IAAI,EAAEvD,IAAI,CAACsB,SADN;AAELjN,MAAAA,IAAI,EAAE,KAAK8U,SAAL,EAFD;AAGLpN,MAAAA,SAAS,EAAE,KAAKwP,cAAL,CAAoBC,OAApB,CAHN;AAIL9M,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD,GATD,CASE;;AAEF;AACF;AACA;AACA;AACA;AACA;AAhBE;;AAmBAuL,EAAAA,MAAM,CAACwH,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAI/S,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAImE,IAAJ;;AAEA,QAAI,KAAKG,mBAAL,CAAyBjH,SAAS,CAACY,SAAnC,CAAJ,EAAmD;AACjDkG,MAAAA,IAAI,GAAG,KAAKC,kBAAL,EAAP;AACA,WAAKzB,WAAL,CAAiBtF,SAAS,CAACa,SAA3B;AACAiG,MAAAA,IAAI,GAAG;AACLrH,QAAAA,IAAI,EAAEvD,IAAI,CAACwB,SADN;AAELoJ,QAAAA,IAAI,EAAEA,IAFD;AAGLlM,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,OAAP;AAKD,KARD,MAQO;AACL8S,MAAAA,IAAI,GAAG,KAAKoB,cAAL,EAAP;AACD;;AAED,QAAI,KAAKjB,mBAAL,CAAyBjH,SAAS,CAACG,IAAnC,CAAJ,EAA8C;AAC5C,aAAO;AACLV,QAAAA,IAAI,EAAEvD,IAAI,CAACyB,aADN;AAELmJ,QAAAA,IAAI,EAAEA,IAFD;AAGLlM,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,OAAP;AAKD;;AAED,WAAO8S,IAAP;AACD;AACD;AACF;AACA;AA5BE;;AA+BAvH,EAAAA,MAAM,CAAC2I,cAAP,GAAwB,SAASA,cAAT,GAA0B;AAChD,QAAIlU,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,WAAO;AACLlD,MAAAA,IAAI,EAAEvD,IAAI,CAACuB,UADN;AAELlN,MAAAA,IAAI,EAAE,KAAK8U,SAAL,EAFD;AAGLzK,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAHA,KAAP;AAKD,GAPD,CAOE;;AAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBE;;AAyBAuL,EAAAA,MAAM,CAACsG,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE;AACA,QAAImD,YAAY,GAAG,KAAKjD,eAAL,KAAyB,KAAKZ,MAAL,CAAYrC,SAAZ,EAAzB,GAAmD,KAAKqC,MAAL,CAAYxC,KAAlF;;AAEA,QAAIqG,YAAY,CAACvJ,IAAb,KAAsBO,SAAS,CAAC5D,IAApC,EAA0C;AACxC,cAAQ4M,YAAY,CAAC9Y,KAArB;AACE,aAAK,QAAL;AACE,iBAAO,KAAK+Y,qBAAL,EAAP;;AAEF,aAAK,QAAL;AACE,iBAAO,KAAKC,yBAAL,EAAP;;AAEF,aAAK,MAAL;AACE,iBAAO,KAAKC,yBAAL,EAAP;;AAEF,aAAK,WAAL;AACE,iBAAO,KAAKC,4BAAL,EAAP;;AAEF,aAAK,OAAL;AACE,iBAAO,KAAKC,wBAAL,EAAP;;AAEF,aAAK,MAAL;AACE,iBAAO,KAAKC,uBAAL,EAAP;;AAEF,aAAK,OAAL;AACE,iBAAO,KAAKC,8BAAL,EAAP;;AAEF,aAAK,WAAL;AACE,iBAAO,KAAKC,wBAAL,EAAP;AAvBJ;AAyBD;;AAED,UAAM,KAAKxD,UAAL,CAAgBgD,YAAhB,CAAN;AACD,GAjCD;;AAmCAzJ,EAAAA,MAAM,CAACwG,eAAP,GAAyB,SAASA,eAAT,GAA2B;AAClD,WAAO,KAAKL,IAAL,CAAU1F,SAAS,CAAC/C,MAApB,KAA+B,KAAKyI,IAAL,CAAU1F,SAAS,CAACiB,YAApB,CAAtC;AACD;AACD;AACF;AACA;AALE;;AAQA1B,EAAAA,MAAM,CAACkK,gBAAP,GAA0B,SAASA,gBAAT,GAA4B;AACpD,QAAI,KAAK1D,eAAL,EAAJ,EAA4B;AAC1B,aAAO,KAAKyC,kBAAL,EAAP;AACD;AACF;AACD;AACF;AACA;AAPE;;AAUAjJ,EAAAA,MAAM,CAAC0J,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;AAC9D,QAAIjV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,QAAnB;AACA,QAAIjC,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIkD,cAAc,GAAG,KAAKlE,IAAL,CAAUxF,SAAS,CAACc,OAApB,EAA6B,KAAK6I,4BAAlC,EAAgE3J,SAAS,CAACgB,OAA1E,CAArB;AACA,WAAO;AACLvB,MAAAA,IAAI,EAAEvD,IAAI,CAAC0B,iBADN;AAEL3B,MAAAA,WAAW,EAAEA,WAFR;AAGLkK,MAAAA,UAAU,EAAEA,UAHP;AAILuD,MAAAA,cAAc,EAAEA,cAJX;AAKL9O,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AAhBE;;AAmBAuL,EAAAA,MAAM,CAACoK,4BAAP,GAAsC,SAASA,4BAAT,GAAwC;AAC5E,QAAI3V,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAIsD,SAAS,GAAG,KAAKK,kBAAL,EAAhB;AACA,SAAKhB,WAAL,CAAiBtF,SAAS,CAACS,KAA3B;AACA,QAAIqG,IAAI,GAAG,KAAKoB,cAAL,EAAX;AACA,WAAO;AACLzI,MAAAA,IAAI,EAAEvD,IAAI,CAAC2B,yBADN;AAELoI,MAAAA,SAAS,EAAEA,SAFN;AAGLa,MAAAA,IAAI,EAAEA,IAHD;AAILlM,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD;AACD;AACF;AACA;AAdE;;AAiBAuL,EAAAA,MAAM,CAAC2J,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE,QAAIlV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,QAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,WAAO;AACL/G,MAAAA,IAAI,EAAEvD,IAAI,CAAC4B,sBADN;AAEL7B,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL4V,MAAAA,UAAU,EAAEA,UAJP;AAKLvL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AACA;AAlBE;;AAqBAuL,EAAAA,MAAM,CAAC4J,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE,QAAInV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,MAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIuE,UAAU,GAAG,KAAKC,yBAAL,EAAjB;AACA,QAAI1D,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAKgB,qBAAL,EAAb;AACA,WAAO;AACLrK,MAAAA,IAAI,EAAEvD,IAAI,CAAC6B,sBADN;AAEL9B,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAILqZ,MAAAA,UAAU,EAAEA,UAJP;AAKLzD,MAAAA,UAAU,EAAEA,UALP;AAML2C,MAAAA,MAAM,EAAEA,MANH;AAOLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AACA;AACA;AAtBE;;AAyBAuL,EAAAA,MAAM,CAACsK,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE,QAAIE,KAAK,GAAG,EAAZ;;AAEA,QAAI,KAAKhC,qBAAL,CAA2B,YAA3B,CAAJ,EAA8C;AAC5C;AACA,WAAKd,mBAAL,CAAyBjH,SAAS,CAACK,GAAnC;;AAEA,SAAG;AACD,YAAI2J,eAAJ;;AAEAD,QAAAA,KAAK,CAAC1X,IAAN,CAAW,KAAK6V,cAAL,EAAX;AACD,OAJD,QAIS,KAAKjB,mBAAL,CAAyBjH,SAAS,CAACK,GAAnC,KAA2C;AACpD,OAAC,CAAC2J,eAAe,GAAG,KAAK5E,QAAxB,MAAsC,IAAtC,IAA8C4E,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,kCAArG,MAA6I,IAA7I,IAAqJ,KAAKvE,IAAL,CAAU1F,SAAS,CAAC5D,IAApB,CALrJ;AAMD;;AAED,WAAO2N,KAAP;AACD;AACD;AACF;AACA;AAnBE;;AAsBAxK,EAAAA,MAAM,CAACuK,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;AAC9D,QAAII,eAAJ,CAD8D,CAG9D;;;AACA,QAAI,CAAC,CAACA,eAAe,GAAG,KAAK9E,QAAxB,MAAsC,IAAtC,IAA8C8E,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,yBAArG,MAAoI,IAApI,IAA4I,KAAKzE,IAAL,CAAU1F,SAAS,CAACc,OAApB,CAA5I,IAA4K,KAAKqE,MAAL,CAAYrC,SAAZ,GAAwBrD,IAAxB,KAAiCO,SAAS,CAACgB,OAA3N,EAAoO;AAClO,WAAKmE,MAAL,CAAYtC,OAAZ;;AAEA,WAAKsC,MAAL,CAAYtC,OAAZ;;AAEA,aAAO,EAAP;AACD;;AAED,WAAO,KAAK6D,YAAL,CAAkB1G,SAAS,CAACc,OAA5B,EAAqC,KAAKsJ,oBAA1C,EAAgEpK,SAAS,CAACgB,OAA1E,CAAP;AACD;AACD;AACF;AACA;AACA;AAjBE;;AAoBAzB,EAAAA,MAAM,CAAC6K,oBAAP,GAA8B,SAASA,oBAAT,GAAgC;AAC5D,QAAIpW,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,QAAIlZ,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIrM,IAAI,GAAG,KAAKqR,iBAAL,EAAX;AACA,SAAK/E,WAAL,CAAiBtF,SAAS,CAACS,KAA3B;AACA,QAAIqG,IAAI,GAAG,KAAKC,kBAAL,EAAX;AACA,QAAIZ,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,WAAO;AACL/G,MAAAA,IAAI,EAAEvD,IAAI,CAAC8B,gBADN;AAEL/B,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL0H,MAAAA,SAAS,EAAEe,IAJN;AAKL8N,MAAAA,IAAI,EAAEA,IALD;AAMLX,MAAAA,UAAU,EAAEA,UANP;AAOLvL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AApBE;;AAuBAuL,EAAAA,MAAM,CAAC8K,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;AACtD,WAAO,KAAK3D,YAAL,CAAkB1G,SAAS,CAACM,OAA5B,EAAqC,KAAKgK,kBAA1C,EAA8DtK,SAAS,CAACO,OAAxE,CAAP;AACD;AACD;AACF;AACA;AACA;AANE;;AASAhB,EAAAA,MAAM,CAAC+K,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAItW,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,QAAIlZ,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,SAAKC,WAAL,CAAiBtF,SAAS,CAACS,KAA3B;AACA,QAAIqG,IAAI,GAAG,KAAKC,kBAAL,EAAX;AACA,QAAIC,YAAJ;;AAEA,QAAI,KAAKC,mBAAL,CAAyBjH,SAAS,CAACU,MAAnC,CAAJ,EAAgD;AAC9CsG,MAAAA,YAAY,GAAG,KAAKE,iBAAL,CAAuB,IAAvB,CAAf;AACD;;AAED,QAAIf,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,WAAO;AACL/G,MAAAA,IAAI,EAAEvD,IAAI,CAAC+B,sBADN;AAELhC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAILuW,MAAAA,IAAI,EAAEA,IAJD;AAKLE,MAAAA,YAAY,EAAEA,YALT;AAMLb,MAAAA,UAAU,EAAEA,UANP;AAOLvL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AACA;AA1BE;;AA6BAuL,EAAAA,MAAM,CAAC6J,4BAAP,GAAsC,SAASA,4BAAT,GAAwC;AAC5E,QAAIpV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,WAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIuE,UAAU,GAAG,KAAKC,yBAAL,EAAjB;AACA,QAAI1D,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAKgB,qBAAL,EAAb;AACA,WAAO;AACLrK,MAAAA,IAAI,EAAEvD,IAAI,CAACgC,yBADN;AAELjC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAILqZ,MAAAA,UAAU,EAAEA,UAJP;AAKLzD,MAAAA,UAAU,EAAEA,UALP;AAML2C,MAAAA,MAAM,EAAEA,MANH;AAOLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AACA;AArBE;;AAwBAuL,EAAAA,MAAM,CAAC8J,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAIrV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,OAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIuD,KAAK,GAAG,KAAKQ,qBAAL,EAAZ;AACA,WAAO;AACL9K,MAAAA,IAAI,EAAEvD,IAAI,CAACiC,qBADN;AAELlC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL4V,MAAAA,UAAU,EAAEA,UAJP;AAKL4D,MAAAA,KAAK,EAAEA,KALF;AAMLnP,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AACA;AACA;AApBE;;AAuBAuL,EAAAA,MAAM,CAACgL,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;AAC9D,QAAIR,KAAK,GAAG,EAAZ;;AAEA,QAAI,KAAK9C,mBAAL,CAAyBjH,SAAS,CAACU,MAAnC,CAAJ,EAAgD;AAC9C;AACA,WAAKuG,mBAAL,CAAyBjH,SAAS,CAACe,IAAnC;;AAEA,SAAG;AACDgJ,QAAAA,KAAK,CAAC1X,IAAN,CAAW,KAAK6V,cAAL,EAAX;AACD,OAFD,QAES,KAAKjB,mBAAL,CAAyBjH,SAAS,CAACe,IAAnC,CAFT;AAGD;;AAED,WAAOgJ,KAAP;AACD;AACD;AACF;AACA;AACA;AAjBE;;AAoBAxK,EAAAA,MAAM,CAAC+J,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;AAClE,QAAItV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,MAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIkC,MAAM,GAAG,KAAK8B,yBAAL,EAAb;AACA,WAAO;AACL/K,MAAAA,IAAI,EAAEvD,IAAI,CAACkC,oBADN;AAELnC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL4V,MAAAA,UAAU,EAAEA,UAJP;AAKLuC,MAAAA,MAAM,EAAEA,MALH;AAML9N,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AAlBE;;AAqBAuL,EAAAA,MAAM,CAACiL,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE,WAAO,KAAK9D,YAAL,CAAkB1G,SAAS,CAACc,OAA5B,EAAqC,KAAK2J,wBAA1C,EAAoEzK,SAAS,CAACgB,OAA9E,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AAPE;;AAUAzB,EAAAA,MAAM,CAACkL,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAIzW,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,QAAIlZ,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,WAAO;AACL/G,MAAAA,IAAI,EAAEvD,IAAI,CAACmC,qBADN;AAELpC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL4V,MAAAA,UAAU,EAAEA,UAJP;AAKLvL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AAhBE;;AAmBAuL,EAAAA,MAAM,CAACgK,8BAAP,GAAwC,SAASA,8BAAT,GAA0C;AAChF,QAAIvV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,OAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAK4B,0BAAL,EAAb;AACA,WAAO;AACLjL,MAAAA,IAAI,EAAEvD,IAAI,CAACoC,4BADN;AAELrC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL4V,MAAAA,UAAU,EAAEA,UAJP;AAKL2C,MAAAA,MAAM,EAAEA,MALH;AAMLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AAlBE;;AAqBAuL,EAAAA,MAAM,CAACmL,0BAAP,GAAoC,SAASA,0BAAT,GAAsC;AACxE,WAAO,KAAKhE,YAAL,CAAkB1G,SAAS,CAACc,OAA5B,EAAqC,KAAKwJ,kBAA1C,EAA8DtK,SAAS,CAACgB,OAAxE,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfE;;AAkBAzB,EAAAA,MAAM,CAACuG,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAIkD,YAAY,GAAG,KAAK7D,MAAL,CAAYrC,SAAZ,EAAnB;;AAEA,QAAIkG,YAAY,CAACvJ,IAAb,KAAsBO,SAAS,CAAC5D,IAApC,EAA0C;AACxC,cAAQ4M,YAAY,CAAC9Y,KAArB;AACE,aAAK,QAAL;AACE,iBAAO,KAAKya,oBAAL,EAAP;;AAEF,aAAK,QAAL;AACE,iBAAO,KAAKC,wBAAL,EAAP;;AAEF,aAAK,MAAL;AACE,iBAAO,KAAKC,wBAAL,EAAP;;AAEF,aAAK,WAAL;AACE,iBAAO,KAAKC,2BAAL,EAAP;;AAEF,aAAK,OAAL;AACE,iBAAO,KAAKC,uBAAL,EAAP;;AAEF,aAAK,MAAL;AACE,iBAAO,KAAKC,sBAAL,EAAP;;AAEF,aAAK,OAAL;AACE,iBAAO,KAAKC,6BAAL,EAAP;AApBJ;AAsBD;;AAED,UAAM,KAAKjF,UAAL,CAAgBgD,YAAhB,CAAN;AACD;AACD;AACF;AACA;AACA;AACA;AAlCE;;AAqCAzJ,EAAAA,MAAM,CAACoL,oBAAP,GAA8B,SAASA,oBAAT,GAAgC;AAC5D,QAAI3W,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,QAAnB;AACA,QAAIjC,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIkD,cAAc,GAAG,KAAKhD,YAAL,CAAkB1G,SAAS,CAACc,OAA5B,EAAqC,KAAK6I,4BAA1C,EAAwE3J,SAAS,CAACgB,OAAlF,CAArB;;AAEA,QAAImF,UAAU,CAAC3U,MAAX,KAAsB,CAAtB,IAA2BkY,cAAc,CAAClY,MAAf,KAA0B,CAAzD,EAA4D;AAC1D,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAACsC,gBADN;AAEL2H,MAAAA,UAAU,EAAEA,UAFP;AAGLuD,MAAAA,cAAc,EAAEA,cAHX;AAIL9O,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD;AACD;AACF;AACA;AACA;AArBE;;AAwBAuL,EAAAA,MAAM,CAACqL,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAI5W,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,QAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;;AAEA,QAAIL,UAAU,CAAC3U,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAACuC,qBADN;AAELlO,MAAAA,IAAI,EAAEA,IAFD;AAGL4V,MAAAA,UAAU,EAAEA,UAHP;AAILvL,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAJA,KAAP;AAMD;AACD;AACF;AACA;AACA;AACA;AACA;AAvBE;;AA0BAuL,EAAAA,MAAM,CAACsL,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAI7W,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,MAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIuE,UAAU,GAAG,KAAKC,yBAAL,EAAjB;AACA,QAAI1D,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAKgB,qBAAL,EAAb;;AAEA,QAAIF,UAAU,CAACpY,MAAX,KAAsB,CAAtB,IAA2B2U,UAAU,CAAC3U,MAAX,KAAsB,CAAjD,IAAsDsX,MAAM,CAACtX,MAAP,KAAkB,CAA5E,EAA+E;AAC7E,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAACwC,qBADN;AAELnO,MAAAA,IAAI,EAAEA,IAFD;AAGLqZ,MAAAA,UAAU,EAAEA,UAHP;AAILzD,MAAAA,UAAU,EAAEA,UAJP;AAKL2C,MAAAA,MAAM,EAAEA,MALH;AAMLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AACA;AACA;AACA;AA3BE;;AA8BAuL,EAAAA,MAAM,CAACuL,2BAAP,GAAqC,SAASA,2BAAT,GAAuC;AAC1E,QAAI9W,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,WAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIuE,UAAU,GAAG,KAAKC,yBAAL,EAAjB;AACA,QAAI1D,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAKgB,qBAAL,EAAb;;AAEA,QAAIF,UAAU,CAACpY,MAAX,KAAsB,CAAtB,IAA2B2U,UAAU,CAAC3U,MAAX,KAAsB,CAAjD,IAAsDsX,MAAM,CAACtX,MAAP,KAAkB,CAA5E,EAA+E;AAC7E,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAACyC,wBADN;AAELpO,MAAAA,IAAI,EAAEA,IAFD;AAGLqZ,MAAAA,UAAU,EAAEA,UAHP;AAILzD,MAAAA,UAAU,EAAEA,UAJP;AAKL2C,MAAAA,MAAM,EAAEA,MALH;AAMLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AANA,KAAP;AAQD;AACD;AACF;AACA;AACA;AACA;AA1BE;;AA6BAuL,EAAAA,MAAM,CAACwL,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;AAClE,QAAI/W,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,OAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIuD,KAAK,GAAG,KAAKQ,qBAAL,EAAZ;;AAEA,QAAIpE,UAAU,CAAC3U,MAAX,KAAsB,CAAtB,IAA2BuY,KAAK,CAACvY,MAAN,KAAiB,CAAhD,EAAmD;AACjD,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAAC0C,oBADN;AAELrO,MAAAA,IAAI,EAAEA,IAFD;AAGL4V,MAAAA,UAAU,EAAEA,UAHP;AAIL4D,MAAAA,KAAK,EAAEA,KAJF;AAKLnP,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AACA;AAxBE;;AA2BAuL,EAAAA,MAAM,CAACyL,sBAAP,GAAgC,SAASA,sBAAT,GAAkC;AAChE,QAAIhX,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,MAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIkC,MAAM,GAAG,KAAK8B,yBAAL,EAAb;;AAEA,QAAIrE,UAAU,CAAC3U,MAAX,KAAsB,CAAtB,IAA2BkX,MAAM,CAAClX,MAAP,KAAkB,CAAjD,EAAoD;AAClD,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAAC2C,mBADN;AAELtO,MAAAA,IAAI,EAAEA,IAFD;AAGL4V,MAAAA,UAAU,EAAEA,UAHP;AAILuC,MAAAA,MAAM,EAAEA,MAJH;AAKL9N,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AACA;AAxBE;;AA2BAuL,EAAAA,MAAM,CAAC0L,6BAAP,GAAuC,SAASA,6BAAT,GAAyC;AAC9E,QAAIjX,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,SAAKyF,aAAL,CAAmB,QAAnB;AACA,SAAKA,aAAL,CAAmB,OAAnB;AACA,QAAI7X,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIc,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;AACA,QAAIsC,MAAM,GAAG,KAAK4B,0BAAL,EAAb;;AAEA,QAAIvE,UAAU,CAAC3U,MAAX,KAAsB,CAAtB,IAA2BsX,MAAM,CAACtX,MAAP,KAAkB,CAAjD,EAAoD;AAClD,YAAM,KAAKwU,UAAL,EAAN;AACD;;AAED,WAAO;AACLvG,MAAAA,IAAI,EAAEvD,IAAI,CAAC4C,2BADN;AAELvO,MAAAA,IAAI,EAAEA,IAFD;AAGL4V,MAAAA,UAAU,EAAEA,UAHP;AAIL2C,MAAAA,MAAM,EAAEA,MAJH;AAKLlO,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AALA,KAAP;AAOD;AACD;AACF;AACA;AACA;AAvBE;;AA0BAuL,EAAAA,MAAM,CAACiK,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;AACpE,QAAIxV,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAI1G,WAAW,GAAG,KAAKwN,gBAAL,EAAlB;AACA,SAAKrB,aAAL,CAAmB,WAAnB;AACA,SAAK9C,WAAL,CAAiBtF,SAAS,CAACW,EAA3B;AACA,QAAIpQ,IAAI,GAAG,KAAK8U,SAAL,EAAX;AACA,QAAIrM,IAAI,GAAG,KAAKqR,iBAAL,EAAX;AACA,QAAIa,UAAU,GAAG,KAAKnD,qBAAL,CAA2B,YAA3B,CAAjB;AACA,SAAKK,aAAL,CAAmB,IAAnB;AACA,QAAI9M,SAAS,GAAG,KAAK6P,uBAAL,EAAhB;AACA,WAAO;AACL1L,MAAAA,IAAI,EAAEvD,IAAI,CAACqC,oBADN;AAELtC,MAAAA,WAAW,EAAEA,WAFR;AAGL1L,MAAAA,IAAI,EAAEA,IAHD;AAIL0H,MAAAA,SAAS,EAAEe,IAJN;AAKLkS,MAAAA,UAAU,EAAEA,UALP;AAML5P,MAAAA,SAAS,EAAEA,SANN;AAOLV,MAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS5G,KAAT;AAPA,KAAP;AASD;AACD;AACF;AACA;AACA;AACA;AAxBE;;AA2BAuL,EAAAA,MAAM,CAAC4L,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;AAClE;AACA,SAAKlE,mBAAL,CAAyBjH,SAAS,CAACe,IAAnC;AACA,QAAIzF,SAAS,GAAG,EAAhB;;AAEA,OAAG;AACDA,MAAAA,SAAS,CAACjJ,IAAV,CAAe,KAAK+Y,sBAAL,EAAf;AACD,KAFD,QAES,KAAKnE,mBAAL,CAAyBjH,SAAS,CAACe,IAAnC,CAFT;;AAIA,WAAOzF,SAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCE;;AAwCAiE,EAAAA,MAAM,CAAC6L,sBAAP,GAAgC,SAASA,sBAAT,GAAkC;AAChE,QAAIpX,KAAK,GAAG,KAAKmR,MAAL,CAAYxC,KAAxB;AACA,QAAIpS,IAAI,GAAG,KAAK8U,SAAL,EAAX;;AAEA,QAAIlE,iBAAiB,CAAC5Q,IAAI,CAACL,KAAN,CAAjB,KAAkCT,SAAtC,EAAiD;AAC/C,aAAOc,IAAP;AACD;;AAED,UAAM,KAAKyV,UAAL,CAAgBhS,KAAhB,CAAN;AACD,GATD,CASE;;AAEF;AACF;AACA;AACA;AAdE;;AAiBAuL,EAAAA,MAAM,CAAC3E,GAAP,GAAa,SAASA,GAAT,CAAawE,UAAb,EAAyB;AACpC,QAAIiM,eAAJ;;AAEA,QAAI,CAAC,CAACA,eAAe,GAAG,KAAKjG,QAAxB,MAAsC,IAAtC,IAA8CiG,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,UAArG,MAAqH,IAAzH,EAA+H;AAC7H,aAAO,IAAInM,QAAJ,CAAaC,UAAb,EAAyB,KAAK+F,MAAL,CAAYzC,SAArC,EAAgD,KAAKyC,MAAL,CAAY/R,MAA5D,CAAP;AACD;AACF;AACD;AACF;AACA;AATE;;AAYAmM,EAAAA,MAAM,CAACmG,IAAP,GAAc,SAASA,IAAT,CAAcjG,IAAd,EAAoB;AAChC,WAAO,KAAK0F,MAAL,CAAYxC,KAAZ,CAAkBlD,IAAlB,KAA2BA,IAAlC;AACD;AACD;AACF;AACA;AACA;AANE;;AASAF,EAAAA,MAAM,CAAC+F,WAAP,GAAqB,SAASA,WAAT,CAAqB7F,IAArB,EAA2B;AAC9C,QAAIkD,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,QAAIA,KAAK,CAAClD,IAAN,KAAeA,IAAnB,EAAyB;AACvB,WAAK0F,MAAL,CAAYtC,OAAZ;;AAEA,aAAOF,KAAP;AACD;;AAED,UAAM3G,WAAW,CAAC,KAAKmJ,MAAL,CAAY/R,MAAb,EAAqBuP,KAAK,CAAC3O,KAA3B,EAAkC,YAAYxD,MAAZ,CAAmB+a,gBAAgB,CAAC9L,IAAD,CAAnC,EAA2C,UAA3C,EAAuDjP,MAAvD,CAA8Dgb,YAAY,CAAC7I,KAAD,CAA1E,EAAmF,GAAnF,CAAlC,CAAjB;AACD;AACD;AACF;AACA;AACA;AAdE;;AAiBApD,EAAAA,MAAM,CAAC0H,mBAAP,GAA6B,SAASA,mBAAT,CAA6BxH,IAA7B,EAAmC;AAC9D,QAAIkD,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,QAAIA,KAAK,CAAClD,IAAN,KAAeA,IAAnB,EAAyB;AACvB,WAAK0F,MAAL,CAAYtC,OAAZ;;AAEA,aAAOF,KAAP;AACD;;AAED,WAAOlT,SAAP;AACD;AACD;AACF;AACA;AACA;AAdE;;AAiBA8P,EAAAA,MAAM,CAAC6I,aAAP,GAAuB,SAASA,aAAT,CAAuBlY,KAAvB,EAA8B;AACnD,QAAIyS,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,QAAIA,KAAK,CAAClD,IAAN,KAAeO,SAAS,CAAC5D,IAAzB,IAAiCuG,KAAK,CAACzS,KAAN,KAAgBA,KAArD,EAA4D;AAC1D,WAAKiV,MAAL,CAAYtC,OAAZ;AACD,KAFD,MAEO;AACL,YAAM7G,WAAW,CAAC,KAAKmJ,MAAL,CAAY/R,MAAb,EAAqBuP,KAAK,CAAC3O,KAA3B,EAAkC,cAAcxD,MAAd,CAAqBN,KAArB,EAA4B,YAA5B,EAA0CM,MAA1C,CAAiDgb,YAAY,CAAC7I,KAAD,CAA7D,EAAsE,GAAtE,CAAlC,CAAjB;AACD;AACF;AACD;AACF;AACA;AACA;AAZE;;AAeApD,EAAAA,MAAM,CAACwI,qBAAP,GAA+B,SAASA,qBAAT,CAA+B7X,KAA/B,EAAsC;AACnE,QAAIyS,KAAK,GAAG,KAAKwC,MAAL,CAAYxC,KAAxB;;AAEA,QAAIA,KAAK,CAAClD,IAAN,KAAeO,SAAS,CAAC5D,IAAzB,IAAiCuG,KAAK,CAACzS,KAAN,KAAgBA,KAArD,EAA4D;AAC1D,WAAKiV,MAAL,CAAYtC,OAAZ;;AAEA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;AACD;AACF;AACA;AACA;AAdE;;AAiBAtD,EAAAA,MAAM,CAACyG,UAAP,GAAoB,SAASA,UAAT,CAAoByF,OAApB,EAA6B;AAC/C,QAAI9I,KAAK,GAAG8I,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmD,KAAKtG,MAAL,CAAYxC,KAA3E;AACA,WAAO3G,WAAW,CAAC,KAAKmJ,MAAL,CAAY/R,MAAb,EAAqBuP,KAAK,CAAC3O,KAA3B,EAAkC,cAAcxD,MAAd,CAAqBgb,YAAY,CAAC7I,KAAD,CAAjC,EAA0C,GAA1C,CAAlC,CAAlB;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AATE;;AAYApD,EAAAA,MAAM,CAACoJ,GAAP,GAAa,SAASA,GAAT,CAAa+C,QAAb,EAAuBC,OAAvB,EAAgCC,SAAhC,EAA2C;AACtD,SAAKtG,WAAL,CAAiBoG,QAAjB;AACA,QAAI3R,KAAK,GAAG,EAAZ;;AAEA,WAAO,CAAC,KAAKkN,mBAAL,CAAyB2E,SAAzB,CAAR,EAA6C;AAC3C7R,MAAAA,KAAK,CAAC1H,IAAN,CAAWsZ,OAAO,CAAC3a,IAAR,CAAa,IAAb,CAAX;AACD;;AAED,WAAO+I,KAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AAhBE;;AAmBAwF,EAAAA,MAAM,CAACmH,YAAP,GAAsB,SAASA,YAAT,CAAsBgF,QAAtB,EAAgCC,OAAhC,EAAyCC,SAAzC,EAAoD;AACxE,QAAI,KAAK3E,mBAAL,CAAyByE,QAAzB,CAAJ,EAAwC;AACtC,UAAI3R,KAAK,GAAG,EAAZ;;AAEA,SAAG;AACDA,QAAAA,KAAK,CAAC1H,IAAN,CAAWsZ,OAAO,CAAC3a,IAAR,CAAa,IAAb,CAAX;AACD,OAFD,QAES,CAAC,KAAKiW,mBAAL,CAAyB2E,SAAzB,CAFV;;AAIA,aAAO7R,KAAP;AACD;;AAED,WAAO,EAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AAlBE;;AAqBAwF,EAAAA,MAAM,CAACiG,IAAP,GAAc,SAASA,IAAT,CAAckG,QAAd,EAAwBC,OAAxB,EAAiCC,SAAjC,EAA4C;AACxD,SAAKtG,WAAL,CAAiBoG,QAAjB;AACA,QAAI3R,KAAK,GAAG,EAAZ;;AAEA,OAAG;AACDA,MAAAA,KAAK,CAAC1H,IAAN,CAAWsZ,OAAO,CAAC3a,IAAR,CAAa,IAAb,CAAX;AACD,KAFD,QAES,CAAC,KAAKiW,mBAAL,CAAyB2E,SAAzB,CAFV;;AAIA,WAAO7R,KAAP;AACD,GATD;;AAWA,SAAOiL,MAAP;AACD,CA37CyB,EAA1B;AA47CA;AACA;AACA;;;AAGA,SAASwG,YAAT,CAAsB7I,KAAtB,EAA6B;AAC3B,MAAIzS,KAAK,GAAGyS,KAAK,CAACzS,KAAlB;AACA,SAAOqb,gBAAgB,CAAC5I,KAAK,CAAClD,IAAP,CAAhB,IAAgCvP,KAAK,IAAI,IAAT,GAAgB,MAAMM,MAAN,CAAaN,KAAb,EAAoB,IAApB,CAAhB,GAA4C,EAA5E,CAAP;AACD;AACD;AACA;AACA;;;AAGA,SAASqb,gBAAT,CAA0B9L,IAA1B,EAAgC;AAC9B,SAAOwD,qBAAqB,CAACxD,IAAD,CAArB,GAA8B,KAAKjP,MAAL,CAAYiP,IAAZ,EAAkB,IAAlB,CAA9B,GAAwDA,IAA/D;AACD;;AAED,MAAMoM,cAAc,GAAG;AACnB3d,EAAAA,GADmB;AAEnBE,EAAAA,MAFmB;AAGnBE,EAAAA,KAHmB;AAInBE,EAAAA,KAJmB;AAKnBC,EAAAA,IALmB;AAMnBE,EAAAA;AANmB,CAAvB;;AAQA,SAASmd,UAAT,CAAoBC,KAApB,EAA2BC,mBAAmB,GAAG,OAAjD,EAA0D;AACtD,MAAIC,EAAJ;;AACA,QAAMC,GAAG,GAAGrH,KAAK,CAACkH,KAAD,CAAjB;AACA,QAAMI,YAAY,GAAGD,GAAG,CAAC3G,WAAJ,CAAgB6G,IAAhB,CAAsBC,GAAD,IAAS;AAC/C,WAAQA,GAAG,CAAC5M,IAAJ,KAAa,qBAAb,KACHuM,mBAAmB,KAAK,KAAxB,IAAiCK,GAAG,CAACpG,SAAJ,KAAkB+F,mBADhD,CAAR;AAEH,GAHoB,CAArB;AAIA,SAAO;AACHM,IAAAA,aAAa,EAAEH,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAClG,SADrF;AAEHsG,IAAAA,aAAa,EAAE,CAACN,EAAE,GAAGE,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAC5b,IAA/E,MAAyF,IAAzF,IAAiG0b,EAAE,KAAK,KAAK,CAA7G,GAAiH,KAAK,CAAtH,GAA0HA,EAAE,CAAC/b;AAFzI,GAAP;AAIH;;AACD,SAASsc,qBAAT,CAA+BC,qBAA/B,EAAsDC,qBAAtD,EAA6EC,IAA7E,EAAmFC,QAAnF,EAA6F;AACzF,SAAO;AACHA,IAAAA,QADG;;AAEH/H,IAAAA,KAAK,CAACgI,GAAD,EAAM;AACP,UAAIZ,EAAJ,CADO,CAEP;AACA;;;AACA,cAAQY,GAAG,CAACC,MAAZ;AACI,aAAK,KAAL;AAAY;AACR,kBAAMf,KAAK,GAAGc,GAAG,CAACE,GAAJ,CAAQC,YAAR,CAAqBpU,GAArB,CAAyB,OAAzB,CAAd;AACA,kBAAMqU,eAAe,GAAGJ,GAAG,CAACE,GAAJ,CAAQC,YAAR,CAAqBpU,GAArB,CAAyB,WAAzB,KAAyC,EAAjE;;AACA,gBAAI,CAACmT,KAAL,EAAY;AACR,qBAAO,IAAP;AACH;;AACD,kBAAMmB,SAAS,GAAGD,eAAe,GAC3Bpe,SAAS,CAACoe,eAAD,CADkB,GAE3B,EAFN;AAGA,kBAAM;AAAEX,cAAAA,aAAF;AAAiBC,cAAAA;AAAjB,gBAAmCT,UAAU,CAACC,KAAD,EAAQU,qBAAR,CAAnD;AACA,mBAAO;AACHH,cAAAA,aADG;AAEHC,cAAAA,aAFG;AAGHW,cAAAA;AAHG,aAAP;AAKH;;AACD,aAAK,MAAL;AAAa;AACT,gBAAI,EAAE,CAACjB,EAAE,GAAGY,GAAG,CAAClZ,IAAV,MAAoB,IAApB,IAA4BsY,EAAE,KAAK,KAAK,CAAxC,GAA4C,KAAK,CAAjD,GAAqDA,EAAE,CAACF,KAA1D,CAAJ,EAAsE;AAClE,qBAAO,IAAP;AACH;;AACD,kBAAM;AAAEA,cAAAA,KAAF;AAASmB,cAAAA;AAAT,gBAAuBL,GAAG,CAAClZ,IAAjC;AACA,kBAAM;AAAE2Y,cAAAA,aAAF;AAAiBC,cAAAA;AAAjB,gBAAmCT,UAAU,CAACC,KAAD,EAAQU,qBAAR,CAAnD;AACA,mBAAO;AACHH,cAAAA,aADG;AAEHC,cAAAA,aAFG;AAGHW,cAAAA;AAHG,aAAP;AAKH;;AACD;AACI,iBAAO,IAAP;AA9BR;AAgCH,KAtCE;;AAuCHC,IAAAA,gBAAgB,CAACN,GAAD,EAAMO,MAAN,EAAc;AAC1B,aAAO7b,MAAM,CAAC8b,MAAP,CAAc9b,MAAM,CAAC8b,MAAP,CAAc,EAAd,EAAkBR,GAAlB,CAAd,EAAsC;AAAEK,QAAAA,SAAS,EAAEE,MAAM,CAACF,SAAP,IAAoB;AAAjC,OAAtC,CAAP;AACH,KAzCE;;AA0CHI,IAAAA,SAAS,CAACT,GAAD,EAAMO,MAAN,EAAc;AACnB,UAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACb,aAAvB,EAAsC;AAClC,eAAO,KAAP;AACH,OAHkB,CAInB;AACA;;;AACA,YAAMgB,eAAe,GAAGxe,eAAe,CAAC8d,GAAG,CAACE,GAAL,EAAUJ,IAAV,CAAvC;AACA,YAAMa,mBAAmB,GAAGd,qBAAqB,YAAYe,MAAjC,GACtBf,qBAAqB,CAACgB,IAAtB,CAA2BN,MAAM,CAACb,aAAlC,CADsB,GAEtBG,qBAAqB,KAAKU,MAAM,CAACb,aAFvC;AAGA,aAAOgB,eAAe,CAACI,OAAhB,IAA2BH,mBAAlC;AACH,KArDE;;AAsDHI,IAAAA,aAAa,GAAG;AACZ,aAAO/B,cAAP;AACH,KAxDE;;AAyDHgC,IAAAA,GAAG,CAAChB,GAAD,EAAMiB,GAAN,EAAWC,OAAX,EAAoBX,MAApB,EAA4B;AAC3B,YAAM;AAAEd,QAAAA,aAAF;AAAiBC,QAAAA;AAAjB,UAAmCa,MAAzC;AACA,YAAMY,aAAa,GAAGhf,cAAc,CAAC6d,GAAD,CAApC;AACA,YAAMoB,cAAc,GAAG/e,eAAe,CAAC4e,GAAD,CAAtC;AACAI,MAAAA,OAAO,CAACC,cAAR,CAAuB,sBAAvB,EAA+C/e,YAAY,EAA3D,EAA+Dmd,aAA/D,EAA+E,SAAQld,kBAAkB,CAACye,GAAG,CAAC1f,MAAL,CAAa,EAAtH,EAAyH0f,GAAG,CAAC1f,MAA7H,EAAqI,eAArI;AACA8f,MAAAA,OAAO,CAACL,GAAR,CAAY,UAAZ,EAAwBG,aAAxB;AACAE,MAAAA,OAAO,CAACL,GAAR,CAAY,UAAZ,EAAwB;AACpBvB,QAAAA,aADoB;AAEpBC,QAAAA,aAAa,EAAEG,qBAFK;AAGpBY,QAAAA,SAAS,EAAES,OAAO,CAACT;AAHC,OAAxB;AAKAY,MAAAA,OAAO,CAACL,GAAR,CAAY,WAAZ,EAAyBI,cAAzB;AACAC,MAAAA,OAAO,CAACE,QAAR;AACH;;AAtEE,GAAP;AAwEH;;AACD,MAAMC,0BAA0B,GAAG,CAAC5B,qBAAD,EAAwBE,IAAxB,KAAiC;AAChE,SAAO,CAACD,qBAAD,EAAwBE,QAAxB,KAAqC;AACxC,WAAOJ,qBAAqB,CAACC,qBAAD,EAAwBC,qBAAxB,EAA+CC,IAA/C,EAAqDC,QAArD,CAA5B;AACH,GAFD;AAGH,CAJD;;AAKA,MAAM0B,6BAA6B,GAAI3B,IAAD,IAAU;AAC5C,SAAQC,QAAD,IAAc;AACjB,WAAOJ,qBAAqB,CAAC,KAAD,EAAQ,IAAIiB,MAAJ,CAAW,IAAX,CAAR,EAA0Bd,IAA1B,EAAgCC,QAAhC,CAA5B;AACH,GAFD;AAGH,CAJD;;AAKA,MAAM2B,uBAAuB,GAAG;AAC5BtI,EAAAA,SAAS,EAAEqI,6BAA6B,CAAC,GAAD,CADZ;AAE5BvC,EAAAA,KAAK,EAAEsC,0BAA0B,CAAC,OAAD,EAAU,GAAV,CAFL;AAG5BG,EAAAA,QAAQ,EAAEH,0BAA0B,CAAC,UAAD,EAAa,GAAb;AAHR,CAAhC;;AAKA,SAASI,iBAAT,CAA2BC,GAA3B,EAAgC;AAC5B,SAAO;AACHzI,IAAAA,SAAS,EAAEqI,6BAA6B,CAACI,GAAD,CADrC;AAEH3C,IAAAA,KAAK,EAAEsC,0BAA0B,CAAC,OAAD,EAAUK,GAAV,CAF9B;AAGHF,IAAAA,QAAQ,EAAEH,0BAA0B,CAAC,UAAD,EAAaK,GAAb;AAHjC,GAAP;AAKH;;AACD,MAAMC,OAAO,GAAGpd,MAAM,CAAC8b,MAAP,CAAc9b,MAAM,CAAC8b,MAAP,CAAc,EAAd,EAAkBkB,uBAAlB,CAAd,EAA0D;AAAEK,EAAAA,IAAI,EAAEH;AAAR,CAA1D,CAAhB;AAEA,SAASE,OAAT,EAAkB9C,cAAlB","sourcesContent":["import { a as set, s as status, d as delay, f as fetch } from './fetch-deps.js';\nimport { d as data, e as errors } from './errors-deps.js';\nimport { j as jsonParse, m as matchRequestUrl, a as prepareRequest, b as prepareResponse, c as getTimestamp, d as getStatusCodeColor } from './matchRequestUrl-deps.js';\n\n// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\nvar nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n\nfunction devAssert(condition, message) {\n  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n\nfunction _typeof$1(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$1(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nfunction isObjectLike(value) {\n  return _typeof$1(value) == 'object' && value !== null;\n}\n\n// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\n\nvar SYMBOL_TO_STRING_TAG = // $FlowFixMe Flow doesn't define `Symbol.toStringTag` yet\ntypeof Symbol === 'function' ? Symbol.toStringTag : '@@toStringTag';\n\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nfunction printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var subLineIndex = Math.floor(columnNum / 80);\n    var subLineColumnNum = columnNum % 80;\n    var subLines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function (subLine) {\n      return ['', subLine];\n    }), [[' ', whitespace(subLineColumnNum - 1) + '^'], ['', subLines[subLineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction leftPad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n\nfunction _typeof$2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$2(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof$2(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nvar GraphQLError = /*#__PURE__*/function (_Error) {\n  _inherits(GraphQLError, _Error);\n\n  var _super = _createSuper(GraphQLError);\n\n  /**\n   * A message describing the Error for debugging purposes.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   *\n   * Note: should be treated as readonly, despite invariant usage.\n   */\n\n  /**\n   * An array of { line, column } locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n  function GraphQLError(message, nodes, source, positions, path, originalError, extensions) {\n    var _locations2, _source2, _positions2, _extensions2;\n\n    var _this;\n\n    _classCallCheck(this, GraphQLError);\n\n    _this = _super.call(this, message); // Compute list of blame nodes.\n\n    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n    var _source = source;\n\n    if (!_source && _nodes) {\n      var _nodes$0$loc;\n\n      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;\n    }\n\n    var _positions = positions;\n\n    if (!_positions && _nodes) {\n      _positions = _nodes.reduce(function (list, node) {\n        if (node.loc) {\n          list.push(node.loc.start);\n        }\n\n        return list;\n      }, []);\n    }\n\n    if (_positions && _positions.length === 0) {\n      _positions = undefined;\n    }\n\n    var _locations;\n\n    if (positions && source) {\n      _locations = positions.map(function (pos) {\n        return getLocation(source, pos);\n      });\n    } else if (_nodes) {\n      _locations = _nodes.reduce(function (list, node) {\n        if (node.loc) {\n          list.push(getLocation(node.loc.source, node.loc.start));\n        }\n\n        return list;\n      }, []);\n    }\n\n    var _extensions = extensions;\n\n    if (_extensions == null && originalError != null) {\n      var originalExtensions = originalError.extensions;\n\n      if (isObjectLike(originalExtensions)) {\n        _extensions = originalExtensions;\n      }\n    }\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      name: {\n        value: 'GraphQLError'\n      },\n      message: {\n        value: message,\n        // By being enumerable, JSON.stringify will include `message` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: true,\n        writable: true\n      },\n      locations: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : undefined,\n        // By being enumerable, JSON.stringify will include `locations` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: _locations != null\n      },\n      path: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: path !== null && path !== void 0 ? path : undefined,\n        // By being enumerable, JSON.stringify will include `path` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: path != null\n      },\n      nodes: {\n        value: _nodes !== null && _nodes !== void 0 ? _nodes : undefined\n      },\n      source: {\n        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : undefined\n      },\n      positions: {\n        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : undefined\n      },\n      originalError: {\n        value: originalError\n      },\n      extensions: {\n        // Coercing falsy values to undefined ensures they will not be included\n        // in JSON.stringify() when not provided.\n        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : undefined,\n        // By being enumerable, JSON.stringify will include `path` in the\n        // resulting output. This ensures that the simplest possible GraphQL\n        // service adheres to the spec.\n        enumerable: _extensions != null\n      }\n    }); // Include (non-enumerable) stack trace.\n\n    if (originalError === null || originalError === void 0 ? void 0 : originalError.stack) {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n      return _possibleConstructorReturn(_this);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError);\n    } else {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(GraphQLError, [{\n    key: \"toString\",\n    value: function toString() {\n      return printError(this);\n    } // FIXME: workaround to not break chai comparisons, should be remove in v16\n    // $FlowFixMe Flow doesn't support computed properties yet\n\n  }, {\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Object';\n    }\n  }]);\n\n  return GraphQLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nfunction printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nfunction syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n\n/**\n * The set of allowed kind values for AST nodes.\n */\nvar Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n\nfunction invariant(condition, message) {\n  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')\n\n  if (!booleanCondition) {\n    throw new Error(message != null ? message : 'Unexpected invariant triggered.');\n  }\n}\n\n/**\n * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`\n */\n\nfunction defineInspect(classObject) {\n  var fn = classObject.prototype.toJSON;\n  typeof fn === 'function' || invariant(0);\n  classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nvar Location = /*#__PURE__*/function () {\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The Token at which this Node begins.\n   */\n\n  /**\n   * The Token at which this Node ends.\n   */\n\n  /**\n   * The Source document the AST represents.\n   */\n  function Location(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  var _proto = Location.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  };\n\n  return Location;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(Location);\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\n\nvar Token = /*#__PURE__*/function () {\n  /**\n   * The kind of Token.\n   */\n\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   */\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  function Token(kind, start, end, line, column, prev, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column;\n    this.value = value;\n    this.prev = prev;\n    this.next = null;\n  }\n\n  var _proto2 = Token.prototype;\n\n  _proto2.toJSON = function toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  };\n\n  return Token;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(Token);\n/**\n * The list of all possible AST node types.\n */\n\nfunction _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }\n\n/**\n * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\n * optional, but they are useful for clients who store GraphQL documents in source files.\n * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\n * be useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\n * The `line` and `column` properties in `locationOffset` are 1-indexed.\n */\nvar Source = /*#__PURE__*/function () {\n  function Source(body) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GraphQL request';\n    var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      line: 1,\n      column: 1\n    };\n    this.body = body;\n    this.name = name;\n    this.locationOffset = locationOffset;\n    this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive.');\n    this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive.');\n  } // $FlowFixMe Flow doesn't support computed properties yet\n\n\n  _createClass$1(Source, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Source';\n    }\n  }]);\n\n  return Source;\n}();\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nvar Lexer = /*#__PURE__*/function () {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  function Lexer(source) {\n    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  var _proto = Lexer.prototype;\n\n  _proto.advance = function advance() {\n    this.lastToken = this.token;\n    var token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n  ;\n\n  _proto.lookahead = function lookahead() {\n    var token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        var _token$next;\n\n        // Note: next is only mutable during parsing, so we cast to allow this.\n        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  };\n\n  return Lexer;\n}();\n/**\n * @internal\n */\n\nfunction isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Token(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Token(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Token(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Token(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Token(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Token(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Token(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Token(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Token(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Token(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Token(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Token(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Token(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Token(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 46 || isNameStart(code)) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n} // _ A-Z a-z\n\n\nfunction isNameStart(code) {\n  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;\n}\n\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        var _this$_options2;\n\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n\nconst graphqlContext = {\r\n    set,\r\n    status,\r\n    delay,\r\n    fetch,\r\n    data,\r\n    errors,\r\n};\r\nfunction parseQuery(query, definitionOperation = 'query') {\r\n    var _a;\r\n    const ast = parse(query);\r\n    const operationDef = ast.definitions.find((def) => {\r\n        return (def.kind === 'OperationDefinition' &&\r\n            (definitionOperation === 'all' || def.operation === definitionOperation));\r\n    });\r\n    return {\r\n        operationType: operationDef === null || operationDef === void 0 ? void 0 : operationDef.operation,\r\n        operationName: (_a = operationDef === null || operationDef === void 0 ? void 0 : operationDef.name) === null || _a === void 0 ? void 0 : _a.value,\r\n    };\r\n}\r\nfunction graphQLRequestHandler(expectedOperationType, expectedOperationName, mask, resolver) {\r\n    return {\r\n        resolver,\r\n        parse(req) {\r\n            var _a;\r\n            // According to the GraphQL specification, a GraphQL request can be issued\r\n            // using both \"GET\" and \"POST\" methods.\r\n            switch (req.method) {\r\n                case 'GET': {\r\n                    const query = req.url.searchParams.get('query');\r\n                    const variablesString = req.url.searchParams.get('variables') || '';\r\n                    if (!query) {\r\n                        return null;\r\n                    }\r\n                    const variables = variablesString\r\n                        ? jsonParse(variablesString)\r\n                        : {};\r\n                    const { operationType, operationName } = parseQuery(query, expectedOperationType);\r\n                    return {\r\n                        operationType,\r\n                        operationName,\r\n                        variables,\r\n                    };\r\n                }\r\n                case 'POST': {\r\n                    if (!((_a = req.body) === null || _a === void 0 ? void 0 : _a.query)) {\r\n                        return null;\r\n                    }\r\n                    const { query, variables } = req.body;\r\n                    const { operationType, operationName } = parseQuery(query, expectedOperationType);\r\n                    return {\r\n                        operationType,\r\n                        operationName,\r\n                        variables,\r\n                    };\r\n                }\r\n                default:\r\n                    return null;\r\n            }\r\n        },\r\n        getPublicRequest(req, parsed) {\r\n            return Object.assign(Object.assign({}, req), { variables: parsed.variables || {} });\r\n        },\r\n        predicate(req, parsed) {\r\n            if (!parsed || !parsed.operationName) {\r\n                return false;\r\n            }\r\n            // Match the request URL against a given mask,\r\n            // in case of an endpoint-specific request handler.\r\n            const hasMatchingMask = matchRequestUrl(req.url, mask);\r\n            const isMatchingOperation = expectedOperationName instanceof RegExp\r\n                ? expectedOperationName.test(parsed.operationName)\r\n                : expectedOperationName === parsed.operationName;\r\n            return hasMatchingMask.matches && isMatchingOperation;\r\n        },\r\n        defineContext() {\r\n            return graphqlContext;\r\n        },\r\n        log(req, res, handler, parsed) {\r\n            const { operationType, operationName } = parsed;\r\n            const loggedRequest = prepareRequest(req);\r\n            const loggedResponse = prepareResponse(res);\r\n            console.groupCollapsed('[MSW] %s %s (%c%s%c)', getTimestamp(), operationName, `color:${getStatusCodeColor(res.status)}`, res.status, 'color:inherit');\r\n            console.log('Request:', loggedRequest);\r\n            console.log('Handler:', {\r\n                operationType,\r\n                operationName: expectedOperationName,\r\n                predicate: handler.predicate,\r\n            });\r\n            console.log('Response:', loggedResponse);\r\n            console.groupEnd();\r\n        },\r\n    };\r\n}\r\nconst createGraphQLScopedHandler = (expectedOperationType, mask) => {\r\n    return (expectedOperationName, resolver) => {\r\n        return graphQLRequestHandler(expectedOperationType, expectedOperationName, mask, resolver);\r\n    };\r\n};\r\nconst createGraphQLOperationHandler = (mask) => {\r\n    return (resolver) => {\r\n        return graphQLRequestHandler('all', new RegExp('.*'), mask, resolver);\r\n    };\r\n};\r\nconst graphqlStandardHandlers = {\r\n    operation: createGraphQLOperationHandler('*'),\r\n    query: createGraphQLScopedHandler('query', '*'),\r\n    mutation: createGraphQLScopedHandler('mutation', '*'),\r\n};\r\nfunction createGraphQLLink(uri) {\r\n    return {\r\n        operation: createGraphQLOperationHandler(uri),\r\n        query: createGraphQLScopedHandler('query', uri),\r\n        mutation: createGraphQLScopedHandler('mutation', uri),\r\n    };\r\n}\r\nconst graphql = Object.assign(Object.assign({}, graphqlStandardHandlers), { link: createGraphQLLink });\n\nexport { graphql, graphqlContext };\n"]},"metadata":{},"sourceType":"module"}