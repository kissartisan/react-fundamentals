{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _slicedToArray from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { c as createCommonjsModule, s as status, a as set, d as delay, f as fetch, l as lib$1, i as isNodeProcess } from './fetch-deps.js';\nimport { p as parse_1 } from './xml-deps.js';\nimport './errors-deps.js';\nexport { i as context } from './index-deps.js';\nimport { g as getPublicUrlFromRequest, i as isStringEqual } from './rest-deps.js';\nexport { R as RESTMethods, r as rest, a as restContext } from './rest-deps.js';\nimport { p as parseBody } from './matchRequestUrl-deps.js';\nexport { m as matchRequestUrl } from './matchRequestUrl-deps.js';\nexport { graphql, graphqlContext } from './graphql.js';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nvar until = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * Gracefully handles a given Promise factory.\n   * @example\n   * cosnt [error, data] = await until(() => asyncAction())\n   */\n\n  exports.until = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(promise) {\n      var data;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return promise()[\"catch\"](function (error) {\n                throw error;\n              });\n\n            case 3:\n              data = _context.sent;\n              return _context.abrupt(\"return\", [null, data]);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              return _context.abrupt(\"return\", [_context.t0, null]);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});\nvar lib = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.until = until.until;\n});\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\n\nvar getWorkerByRegistration = function getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  var allStates = [registration.active, registration.installing, registration.waiting];\n  var existingStates = allStates.filter(Boolean);\n  var mockWorker = existingStates.find(function (worker) {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\n\n\nvar getWorkerInstance = function getWorkerInstance(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var absoluteWorkerUrl, _yield$lib$until, _yield$lib$until2, mockRegistrations, _mockRegistrations, existingRegistration, _yield$lib$until3, _yield$lib$until4, error, instance, isWorkerMissing, scopeUrl;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            // Resolve the absolute Service Worker URL.\n            absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n            _context4.next = 3;\n            return lib.until(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                var registrations;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return navigator.serviceWorker.getRegistrations();\n\n                      case 2:\n                        registrations = _context2.sent;\n                        return _context2.abrupt(\"return\", registrations.filter(function (registration) {\n                          return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\n                        }));\n\n                      case 4:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n            });\n\n          case 3:\n            _yield$lib$until = _context4.sent;\n            _yield$lib$until2 = _slicedToArray(_yield$lib$until, 2);\n            mockRegistrations = _yield$lib$until2[1];\n\n            if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n              // Reload the page when it has associated workers, but no active controller.\n              // The absence of a controller can mean either:\n              // - page has no Service Worker associated with it\n              // - page has been hard-reloaded and its workers won't be used until the next reload.\n              // Since we've checked that there are registrations associated with this page,\n              // at this point we are sure it's hard reload that falls into this clause.\n              location.reload();\n            }\n\n            _mockRegistrations = _slicedToArray(mockRegistrations, 1), existingRegistration = _mockRegistrations[0];\n\n            if (!existingRegistration) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", existingRegistration.update().then(function () {\n              return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n            }));\n\n          case 10:\n            _context4.next = 12;\n            return lib.until(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                var registration;\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return navigator.serviceWorker.register(url, options);\n\n                      case 2:\n                        registration = _context3.sent;\n                        return _context3.abrupt(\"return\", [// Compare existing worker registration by its worker URL,\n                        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n                        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration]);\n\n                      case 4:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n            });\n\n          case 12:\n            _yield$lib$until3 = _context4.sent;\n            _yield$lib$until4 = _slicedToArray(_yield$lib$until3, 2);\n            error = _yield$lib$until4[0];\n            instance = _yield$lib$until4[1];\n\n            if (!error) {\n              _context4.next = 24;\n              break;\n            }\n\n            isWorkerMissing = error.message.includes('(404)'); // Produce a custom error message when given a non-existing Service Worker url.\n            // Suggest developers to check their setup.\n\n            if (!isWorkerMissing) {\n              _context4.next = 22;\n              break;\n            }\n\n            scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\n            console.error(\"[MSW] Failed to register a Service Worker for scope ('\".concat(scopeUrl.href, \"') with script ('\").concat(absoluteWorkerUrl, \"'): Service Worker script does not exist at the given path.\\n\\nDid you forget to run \\\"npx msw init <PUBLIC_DIR>\\\"?\\n\\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init\"));\n            return _context4.abrupt(\"return\", null);\n\n          case 22:\n            // Fallback error message for any other registration errors.\n            console.error(\"[MSW] Failed to register a Service Worker:\\nm\".concat(error.message));\n            return _context4.abrupt(\"return\", null);\n\n          case 24:\n            return _context4.abrupt(\"return\", instance);\n\n          case 25:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n};\n\nvar activateMocking = function activateMocking(context, options) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var _a;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_ACTIVATE');\n            return _context5.abrupt(\"return\", context.events.once('MOCKING_ENABLED').then(function () {\n              if (!(options === null || options === void 0 ? void 0 : options.quiet)) {\n                console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');\n                console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\n                console.log('Found an issue? https://github.com/mswjs/msw/issues');\n                console.groupEnd();\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n};\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\n\n\nvar createBroadcastChannel = function createBroadcastChannel(event) {\n  var port = event.ports[0];\n  return {\n    /**\r\n     * Sends a text message to the connected Service Worker.\r\n     */\n    send: function send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n  };\n};\n\nvar defaultContext = {\n  status: status,\n  set: set,\n  delay: delay,\n  fetch: fetch\n};\n/**\r\n * Composes a given list of functions into a new function that\r\n * executes from right to left.\r\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  return funcs.reduce(function (f, g) {\n    return function () {\n      return f(g.apply(void 0, arguments));\n    };\n  });\n}\n\nvar NetworkError = /*#__PURE__*/function (_Error) {\n  _inherits(NetworkError, _Error);\n\n  var _super = _createSuper(NetworkError);\n\n  function NetworkError(message) {\n    var _this;\n\n    _classCallCheck(this, NetworkError);\n\n    _this = _super.call(this, message);\n    _this.name = 'NetworkError';\n    return _this;\n  }\n\n  return NetworkError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar defaultResponse = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false\n};\n\nfunction createResponseComposition() {\n  var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function () {\n    var resolvedResponse = Object.assign({}, defaultResponse, {\n      headers: new lib$1.Headers({\n        'x-powered-by': 'msw'\n      })\n    }, overrides);\n\n    if (arguments.length > 0) {\n      return compose.apply(void 0, arguments)(resolvedResponse);\n    }\n\n    return resolvedResponse;\n  };\n}\n\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError: function networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\n\nvar getResponse = function getResponse(req, handlers) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var relevantHandlers, _yield$relevantHandle, requestHandler, parsedRequest, mockedResponse, publicRequest;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            relevantHandlers = handlers.filter(function (requestHandler) {\n              // Skip a handler if it has been already used for a one-time response.\n              return !requestHandler.shouldSkip;\n            }).map(function (requestHandler) {\n              // Parse the captured request to get additional information.\n              // Make the predicate function accept all the necessary information\n              // to decide on the interception.\n              var parsedRequest = requestHandler.parse ? requestHandler.parse(req) : null;\n              return [requestHandler, parsedRequest];\n            }).filter(function (_ref2) {\n              var _ref3 = _slicedToArray(_ref2, 2),\n                  requestHandler = _ref3[0],\n                  parsedRequest = _ref3[1];\n\n              return requestHandler.predicate(req, parsedRequest);\n            });\n\n            if (!(relevantHandlers.length == 0)) {\n              _context7.next = 3;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", {\n              handler: null,\n              response: null\n            });\n\n          case 3:\n            _context7.next = 5;\n            return relevantHandlers.reduce(function (asyncAcc, _ref4) {\n              var _ref5 = _slicedToArray(_ref4, 2),\n                  requestHandler = _ref5[0],\n                  parsedRequest = _ref5[1];\n\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                var acc, getPublicRequest, defineContext, resolver, publicRequest, context, mockedResponse;\n                return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.next = 2;\n                        return asyncAcc;\n\n                      case 2:\n                        acc = _context6.sent;\n\n                        if (!acc.requestHandler) {\n                          _context6.next = 5;\n                          break;\n                        }\n\n                        return _context6.abrupt(\"return\", acc);\n\n                      case 5:\n                        getPublicRequest = requestHandler.getPublicRequest, defineContext = requestHandler.defineContext, resolver = requestHandler.resolver;\n                        publicRequest = getPublicRequest ? getPublicRequest(req, parsedRequest) : req;\n                        context = defineContext ? defineContext(publicRequest) : defaultContext;\n                        _context6.next = 10;\n                        return resolver(publicRequest, response, context);\n\n                      case 10:\n                        mockedResponse = _context6.sent;\n\n                        if (mockedResponse) {\n                          _context6.next = 13;\n                          break;\n                        }\n\n                        return _context6.abrupt(\"return\", acc);\n\n                      case 13:\n                        if (mockedResponse && mockedResponse.once) {\n                          // When responded with a one-time response, match the relevant request handler\n                          // as skipped, so it cannot affect the captured requests anymore.\n                          requestHandler.shouldSkip = true;\n                        }\n\n                        return _context6.abrupt(\"return\", {\n                          requestHandler: requestHandler,\n                          parsedRequest: parsedRequest,\n                          mockedResponse: mockedResponse,\n                          publicRequest: publicRequest\n                        });\n\n                      case 15:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }));\n            }, Promise.resolve({\n              mockedResponse: null\n            }));\n\n          case 5:\n            _yield$relevantHandle = _context7.sent;\n            requestHandler = _yield$relevantHandle.requestHandler;\n            parsedRequest = _yield$relevantHandle.parsedRequest;\n            mockedResponse = _yield$relevantHandle.mockedResponse;\n            publicRequest = _yield$relevantHandle.publicRequest;\n\n            if (requestHandler) {\n              _context7.next = 12;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", {\n              handler: null,\n              response: null\n            });\n\n          case 12:\n            return _context7.abrupt(\"return\", {\n              handler: requestHandler,\n              response: mockedResponse,\n              publicRequest: publicRequest,\n              parsedRequest: parsedRequest\n            });\n\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n};\n\nfunction onUnhandledRequest(request) {\n  var onUnhandledRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bypass';\n\n  if (typeof onUnhandledRequest === 'function') {\n    onUnhandledRequest(request);\n    return;\n  }\n\n  var publicUrl = getPublicUrlFromRequest(request);\n  var message = \"captured a \".concat(request.method, \" \").concat(request.url, \" request without a corresponding request handler.\\n\\n  If you wish to intercept this request, consider creating a request handler for it:\\n\\n  rest.\").concat(request.method.toLowerCase(), \"('\").concat(publicUrl, \"', (req, res, ctx) => {\\n    return res(ctx.text('body'))\\n  })\");\n\n  switch (onUnhandledRequest) {\n    case 'error':\n      {\n        throw new Error(\"[MSW] Error: \".concat(message));\n      }\n\n    case 'warn':\n      {\n        console.warn(\"[MSW] Warning: \".concat(message));\n      }\n\n    default:\n      return;\n  }\n}\n\nfunction getAllCookies() {\n  return parse_1(document.cookie);\n}\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\n\n\nfunction getRequestCookies(req) {\n  switch (req.credentials) {\n    case 'same-origin':\n      {\n        // Return document cookies only when requested a resource\n        // from the same origin as the current document.\n        return location.origin === req.url.origin ? getAllCookies() : {};\n      }\n\n    case 'include':\n      {\n        // Return all document cookies.\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n}\n\nvar handleRequestWith = function handleRequestWith(context, options) {\n  return function (event) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var channel, message, type, req, _yield$getResponse, _response, handler, publicRequest, parsedRequest, responseWithSerializedHeaders;\n\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              channel = createBroadcastChannel(event);\n              _context8.prev = 1;\n              message = JSON.parse(event.data, function (key, value) {\n                if (key === 'url') {\n                  return new URL(value);\n                } // Serialize headers\n\n\n                if (key === 'headers') {\n                  return new lib$1.Headers(value);\n                } // Prevent empty fields from presering an empty value.\n                // It's invalid to perform a GET request with { body: \"\" }\n\n\n                if ( // Check if we are parsing deeper in `event.data.payload`,\n                // because this custom JSON parser is invoked for each depth level.\n                this.method && isStringEqual(this.method, 'GET') && key === 'body' && value === '') {\n                  return undefined;\n                }\n\n                return value;\n              });\n              type = message.type, req = message.payload; // Ignore irrelevant worker message types\n\n              if (!(type !== 'REQUEST')) {\n                _context8.next = 6;\n                break;\n              }\n\n              return _context8.abrupt(\"return\", null);\n\n            case 6:\n              // Parse the request's body based on the \"Content-Type\" header.\n              req.body = parseBody(req.body, req.headers); // Set document cookies on the request.\n\n              req.cookies = getRequestCookies(req);\n              _context8.next = 10;\n              return getResponse(req, context.requestHandlers);\n\n            case 10:\n              _yield$getResponse = _context8.sent;\n              _response = _yield$getResponse.response;\n              handler = _yield$getResponse.handler;\n              publicRequest = _yield$getResponse.publicRequest;\n              parsedRequest = _yield$getResponse.parsedRequest;\n\n              if (handler) {\n                _context8.next = 18;\n                break;\n              }\n\n              onUnhandledRequest(req, options.onUnhandledRequest);\n              return _context8.abrupt(\"return\", channel.send({\n                type: 'MOCK_NOT_FOUND'\n              }));\n\n            case 18:\n              if (_response) {\n                _context8.next = 21;\n                break;\n              }\n\n              console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', _response);\n              return _context8.abrupt(\"return\", channel.send({\n                type: 'MOCK_NOT_FOUND'\n              }));\n\n            case 21:\n              responseWithSerializedHeaders = Object.assign(Object.assign({}, _response), {\n                headers: lib$1.headersToList(_response.headers)\n              });\n\n              if (!options.quiet) {\n                setTimeout(function () {\n                  handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);\n                }, _response.delay);\n              }\n\n              channel.send({\n                type: 'MOCK_SUCCESS',\n                payload: responseWithSerializedHeaders\n              });\n              _context8.next = 31;\n              break;\n\n            case 26:\n              _context8.prev = 26;\n              _context8.t0 = _context8[\"catch\"](1);\n\n              if (!(_context8.t0 instanceof NetworkError)) {\n                _context8.next = 30;\n                break;\n              }\n\n              return _context8.abrupt(\"return\", channel.send({\n                type: 'NETWORK_ERROR',\n                payload: {\n                  name: _context8.t0.name,\n                  message: _context8.t0.message\n                }\n              }));\n\n            case 30:\n              // Treat all the other exceptions in a request handler\n              // as unintended, alerting that there is a problem needs fixing.\n              channel.send({\n                type: 'INTERNAL_ERROR',\n                payload: {\n                  status: 500,\n                  body: JSON.stringify({\n                    errorType: _context8.t0.constructor.name,\n                    message: _context8.t0.message,\n                    location: _context8.t0.stack\n                  })\n                }\n              });\n\n            case 31:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8, null, [[1, 26]]);\n    }));\n  };\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n    var _yield$context$events, actualChecksum;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            // Signal Service Worker to report back its integrity\n            serviceWorker.postMessage('INTEGRITY_CHECK_REQUEST');\n            _context9.next = 3;\n            return context.events.once('INTEGRITY_CHECK_RESPONSE');\n\n          case 3:\n            _yield$context$events = _context9.sent;\n            actualChecksum = _yield$context$events.payload;\n\n            if (!(actualChecksum !== \"d1e0e502f550d40a34bee90822e4bf98\")) {\n              _context9.next = 7;\n              break;\n            }\n\n            throw new Error(\"Currently active Service Worker (\".concat(actualChecksum, \") is behind the latest published one (\", \"d1e0e502f550d40a34bee90822e4bf98\", \").\"));\n\n          case 7:\n            return _context9.abrupt(\"return\", serviceWorker);\n\n          case 8:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n}\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\n\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  var _this3 = this;\n\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  var originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    lib.until(function () {\n      return predicatePromise;\n    }).then(function () {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n\n      _this2.send.apply(_this2, args);\n    });\n  }; // Defer any `fetch` requests until the Service Worker is ready.\n\n\n  var originalFetch = window.fetch;\n\n  window.fetch = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n      var _window;\n\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return lib.until(function () {\n                return predicatePromise;\n              });\n\n            case 2:\n              window.fetch = originalFetch;\n              return _context10.abrupt(\"return\", (_window = window).fetch.apply(_window, args));\n\n            case 4:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n  };\n}\n\nfunction isObject(obj) {\n  return typeof obj === 'object';\n}\n/**\r\n * Deeply merges two given objects with the right one\r\n * having a priority during property assignment.\r\n */\n\n\nfunction mergeRight(a, b) {\n  var result = Object.assign({}, a);\n  Object.entries(b).forEach(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        key = _ref7[0],\n        value = _ref7[1];\n\n    var existingValue = result[key];\n\n    if (Array.isArray(existingValue) && Array.isArray(value)) {\n      result[key] = existingValue.concat(value);\n      return;\n    }\n\n    if (isObject(existingValue) && isObject(value)) {\n      result[key] = mergeRight(existingValue, value);\n      return;\n    }\n\n    result[key] = value;\n  });\n  return result;\n}\n\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'bypass',\n  findWorker: function findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\nvar createStart = function createStart(context) {\n  /**\r\n   * Registers and activates the mock Service Worker.\r\n   */\n  return function start(options) {\n    var _this4 = this;\n\n    var resolvedOptions = mergeRight(DEFAULT_START_OPTIONS, options || {});\n\n    var startWorkerInstance = function startWorkerInstance() {\n      return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var _yield$lib$until5, _yield$lib$until6, instance, _instance, worker, registration, _yield$lib$until7, _yield$lib$until8, integrityError, _yield$lib$until9, _yield$lib$until10, activationError;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if ('serviceWorker' in navigator) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                console.error(\"[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).\");\n                return _context11.abrupt(\"return\", null);\n\n              case 3:\n                // Remove all previously existing event listeners.\n                // This way none of the listeners persists between Fast refresh\n                // of the application's code.\n                context.events.removeAllListeners();\n                context.events.addListener(navigator.serviceWorker, 'message', handleRequestWith(context, resolvedOptions));\n                _context11.next = 7;\n                return lib.until(function () {\n                  return getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options, resolvedOptions.findWorker);\n                });\n\n              case 7:\n                _yield$lib$until5 = _context11.sent;\n                _yield$lib$until6 = _slicedToArray(_yield$lib$until5, 2);\n                instance = _yield$lib$until6[1];\n\n                if (instance) {\n                  _context11.next = 12;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", null);\n\n              case 12:\n                _instance = _slicedToArray(instance, 2), worker = _instance[0], registration = _instance[1];\n\n                if (worker) {\n                  _context11.next = 16;\n                  break;\n                }\n\n                if (options === null || options === void 0 ? void 0 : options.findWorker) {\n                  console.error(\"[MSW] Failed to locate the Service Worker registration using a custom \\\"findWorker\\\" predicate.\\n\\nPlease ensure that the custom predicate properly locates the Service Worker registration at \\\"\".concat(resolvedOptions.serviceWorker.url, \"\\\".\\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\\n\"));\n                } else {\n                  console.error(\"[MSW] Failed to locate the Service Worker registration.\\n\\nThis most likely means that the worker script URL \\\"\".concat(resolvedOptions.serviceWorker.url, \"\\\" cannot resolve against the actual public hostname (\").concat(location.host, \"). This may happen if your application runs behind a proxy, or has a dynamic hostname.\\n\\nPlease consider using a custom \\\"serviceWorker.url\\\" option to point to the actual worker script location, or a custom \\\"findWorker\\\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start\"));\n                }\n\n                return _context11.abrupt(\"return\", null);\n\n              case 16:\n                context.worker = worker;\n                context.registration = registration;\n                context.events.addListener(window, 'beforeunload', function () {\n                  if (worker.state !== 'redundant') {\n                    // Notify the Service Worker that this client has closed.\n                    // Internally, it's similar to disabling the mocking, only\n                    // client close event has a handler that self-terminates\n                    // the Service Worker when there are no open clients.\n                    worker.postMessage('CLIENT_CLOSED');\n                  } // Make sure we're always clearing the interval - there are reports that not doing this can\n                  // cause memory leaks in headless browser environments.\n\n\n                  window.clearInterval(context.keepAliveInterval);\n                }); // Check if the active Service Worker is the latest published one\n\n                _context11.next = 21;\n                return lib.until(function () {\n                  return requestIntegrityCheck(context, worker);\n                });\n\n              case 21:\n                _yield$lib$until7 = _context11.sent;\n                _yield$lib$until8 = _slicedToArray(_yield$lib$until7, 1);\n                integrityError = _yield$lib$until8[0];\n\n                if (integrityError) {\n                  console.error(\"[MSW] Detected outdated Service Worker: \".concat(integrityError.message, \"\\n\\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\\n\\n$ npx msw init <PUBLIC_DIR>\\n\\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      \"));\n                } // Signal the Service Worker to enable requests interception\n\n\n                _context11.next = 27;\n                return lib.until(function () {\n                  return activateMocking(context, options);\n                });\n\n              case 27:\n                _yield$lib$until9 = _context11.sent;\n                _yield$lib$until10 = _slicedToArray(_yield$lib$until9, 1);\n                activationError = _yield$lib$until10[0];\n\n                if (!activationError) {\n                  _context11.next = 33;\n                  break;\n                }\n\n                console.error('Failed to enable mocking', activationError);\n                return _context11.abrupt(\"return\", null);\n\n              case 33:\n                context.keepAliveInterval = window.setInterval(function () {\n                  return worker.postMessage('KEEPALIVE_REQUEST');\n                }, 5000);\n                return _context11.abrupt(\"return\", registration);\n\n              case 35:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n    };\n\n    var workerRegistration = startWorkerInstance(); // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n\n    if (resolvedOptions.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n};\n\nvar createStop = function createStop(context) {\n  /**\r\n   * Signal the Service Worker to disable mocking for this client.\r\n   * Use this an an explicit way to stop the mocking, while preserving\r\n   * the worker-client relation. Does not affect the worker's lifecycle.\r\n   */\n  return function stop() {\n    var _a;\n\n    (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_DEACTIVATE');\n    context.events.removeAllListeners();\n    window.clearInterval(context.keepAliveInterval);\n  };\n};\n\nfunction _use(currentHandlers) {\n  for (var _len4 = arguments.length, handlers = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    handlers[_key4 - 1] = arguments[_key4];\n  }\n\n  currentHandlers.unshift.apply(currentHandlers, handlers);\n}\n\nfunction _restoreHandlers(handlers) {\n  handlers.forEach(function (handler) {\n    if ('shouldSkip' in handler) {\n      handler.shouldSkip = false;\n    }\n  });\n}\n\nfunction _resetHandlers(initialHandlers) {\n  for (var _len5 = arguments.length, nextHandlers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    nextHandlers[_key5 - 1] = arguments[_key5];\n  }\n\n  return nextHandlers.length > 0 ? [].concat(nextHandlers) : _toConsumableArray(initialHandlers);\n} // Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\n\n\nvar listeners = [];\n\nfunction setupWorker() {\n  for (var _len6 = arguments.length, requestHandlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    requestHandlers[_key6] = arguments[_key6];\n  }\n\n  requestHandlers.forEach(function (handler) {\n    if (Array.isArray(handler)) throw new Error(\"[MSW] Failed to call \\\"setupWorker\\\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).\");\n  });\n  var context = {\n    worker: null,\n    registration: null,\n    requestHandlers: [].concat(requestHandlers),\n    events: {\n      addListener: function addListener(target, event, callback) {\n        target.addEventListener(event, callback);\n        listeners.push({\n          event: event,\n          target: target,\n          callback: callback\n        });\n        return function () {\n          target.removeEventListener(event, callback);\n        };\n      },\n      removeAllListeners: function removeAllListeners() {\n        var _iterator = _createForOfIteratorHelper(listeners),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _step.value,\n                target = _step$value.target,\n                event = _step$value.event,\n                callback = _step$value.callback;\n            target.removeEventListener(event, callback);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        listeners = [];\n      },\n      once: function once(type) {\n        var bindings = [];\n        return new Promise(function (resolve, reject) {\n          var handleIncomingMessage = function handleIncomingMessage(event) {\n            try {\n              var message = JSON.parse(event.data);\n\n              if (message.type === type) {\n                resolve(message);\n              }\n            } catch (error) {\n              reject(error);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\n        })[\"finally\"](function () {\n          bindings.forEach(function (unbind) {\n            return unbind();\n          });\n        });\n      }\n    }\n  }; // Error when attempting to run this function in a NodeJS environment.\n\n  if (isNodeProcess()) {\n    throw new Error('[MSW] Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for NodeJS environment instead.');\n  }\n\n  return {\n    start: createStart(context),\n    stop: createStop(context),\n    use: function use() {\n      for (var _len7 = arguments.length, handlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        handlers[_key7] = arguments[_key7];\n      }\n\n      _use.apply(void 0, [context.requestHandlers].concat(handlers));\n    },\n    restoreHandlers: function restoreHandlers() {\n      _restoreHandlers(context.requestHandlers);\n    },\n    resetHandlers: function resetHandlers() {\n      for (var _len8 = arguments.length, nextHandlers = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        nextHandlers[_key8] = arguments[_key8];\n      }\n\n      context.requestHandlers = _resetHandlers.apply(void 0, [requestHandlers].concat(nextHandlers));\n    }\n  };\n}\n\nexport { defaultContext, response, setupWorker };","map":{"version":3,"sources":["/Users/kissartisan/playground/learn/React/react-fundamentals/node_modules/msw/lib/esm/index.js"],"names":["c","createCommonjsModule","s","status","a","set","d","delay","f","fetch","l","lib$1","i","isNodeProcess","p","parse_1","context","g","getPublicUrlFromRequest","isStringEqual","R","RESTMethods","r","rest","restContext","parseBody","m","matchRequestUrl","graphql","graphqlContext","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","until","module","exports","Object","defineProperty","promise","error","data","lib","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","getAbsoluteWorkerUrl","relativeUrl","URL","location","origin","href","getWorkerInstance","url","options","navigator","serviceWorker","getRegistrations","registrations","mockRegistrations","controller","length","reload","existingRegistration","update","register","instance","isWorkerMissing","message","includes","scopeUrl","scope","console","activateMocking","_a","postMessage","events","once","quiet","groupCollapsed","log","groupEnd","createBroadcastChannel","event","port","ports","send","defaultContext","compose","funcs","reduce","NetworkError","name","Error","defaultResponse","statusText","body","createResponseComposition","overrides","resolvedResponse","assign","headers","Headers","response","networkError","getResponse","req","handlers","relevantHandlers","requestHandler","shouldSkip","map","parsedRequest","parse","predicate","handler","asyncAcc","acc","getPublicRequest","defineContext","resolver","publicRequest","mockedResponse","onUnhandledRequest","request","publicUrl","method","toLowerCase","warn","getAllCookies","document","cookie","getRequestCookies","credentials","handleRequestWith","channel","JSON","key","undefined","type","payload","cookies","requestHandlers","responseWithSerializedHeaders","headersToList","setTimeout","stringify","errorType","constructor","stack","requestIntegrityCheck","actualChecksum","deferNetworkRequestsUntil","predicatePromise","originalXhrSend","window","XMLHttpRequest","prototype","args","originalFetch","isObject","obj","mergeRight","b","entries","forEach","existingValue","Array","isArray","concat","DEFAULT_START_OPTIONS","waitUntilReady","mockServiceWorkerUrl","createStart","start","resolvedOptions","startWorkerInstance","removeAllListeners","addListener","host","state","clearInterval","keepAliveInterval","integrityError","activationError","setInterval","workerRegistration","createStop","stop","use","currentHandlers","unshift","restoreHandlers","resetHandlers","initialHandlers","nextHandlers","listeners","setupWorker","target","callback","addEventListener","push","removeEventListener","bindings","handleIncomingMessage","unbind"],"mappings":"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","sourcesContent":["import { c as createCommonjsModule, s as status, a as set, d as delay, f as fetch, l as lib$1, i as isNodeProcess } from './fetch-deps.js';\nimport { p as parse_1 } from './xml-deps.js';\nimport './errors-deps.js';\nexport { i as context } from './index-deps.js';\nimport { g as getPublicUrlFromRequest, i as isStringEqual } from './rest-deps.js';\nexport { R as RESTMethods, r as rest, a as restContext } from './rest-deps.js';\nimport { p as parseBody } from './matchRequestUrl-deps.js';\nexport { m as matchRequestUrl } from './matchRequestUrl-deps.js';\nexport { graphql, graphqlContext } from './graphql.js';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nvar until = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\nexports.until = async (promise) => {\n    try {\n        const data = await promise().catch((error) => {\n            throw error;\n        });\n        return [null, data];\n    }\n    catch (error) {\n        return [error, null];\n    }\n};\n});\n\nvar lib = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.until = until.until;\n});\n\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\r\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\r\n    const allStates = [\r\n        registration.active,\r\n        registration.installing,\r\n        registration.waiting,\r\n    ];\r\n    const existingStates = allStates.filter(Boolean);\r\n    const mockWorker = existingStates.find((worker) => {\r\n        return findWorker(worker.scriptURL, absoluteWorkerUrl);\r\n    });\r\n    return mockWorker || null;\r\n};\n\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\r\nfunction getAbsoluteWorkerUrl(relativeUrl) {\r\n    return new URL(relativeUrl, location.origin).href;\r\n}\n\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\r\nconst getWorkerInstance = (url, options = {}, findWorker) => __awaiter(void 0, void 0, void 0, function* () {\r\n    // Resolve the absolute Service Worker URL.\r\n    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\r\n    const [, mockRegistrations] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\r\n        const registrations = yield navigator.serviceWorker.getRegistrations();\r\n        return registrations.filter((registration) => {\r\n            return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\r\n        });\r\n    }));\r\n    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\r\n        // Reload the page when it has associated workers, but no active controller.\r\n        // The absence of a controller can mean either:\r\n        // - page has no Service Worker associated with it\r\n        // - page has been hard-reloaded and its workers won't be used until the next reload.\r\n        // Since we've checked that there are registrations associated with this page,\r\n        // at this point we are sure it's hard reload that falls into this clause.\r\n        location.reload();\r\n    }\r\n    const [existingRegistration] = mockRegistrations;\r\n    if (existingRegistration) {\r\n        // When the Service Worker is registered, update it and return the reference.\r\n        return existingRegistration.update().then(() => {\r\n            return [\r\n                getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker),\r\n                existingRegistration,\r\n            ];\r\n        });\r\n    }\r\n    // When the Service Worker wasn't found, register it anew and return the reference.\r\n    const [error, instance] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\r\n        const registration = yield navigator.serviceWorker.register(url, options);\r\n        return [\r\n            // Compare existing worker registration by its worker URL,\r\n            // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\r\n            getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\r\n            registration,\r\n        ];\r\n    }));\r\n    // Handle Service Worker registration errors.\r\n    if (error) {\r\n        const isWorkerMissing = error.message.includes('(404)');\r\n        // Produce a custom error message when given a non-existing Service Worker url.\r\n        // Suggest developers to check their setup.\r\n        if (isWorkerMissing) {\r\n            const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\r\n            console.error(`\\\n[MSW] Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`);\r\n            return null;\r\n        }\r\n        // Fallback error message for any other registration errors.\r\n        console.error(`[MSW] Failed to register a Service Worker:\\n\\m${error.message}`);\r\n        return null;\r\n    }\r\n    return instance;\r\n});\n\nconst activateMocking = (context, options) => __awaiter(void 0, void 0, void 0, function* () {\r\n    var _a;\r\n    (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_ACTIVATE');\r\n    return context.events.once('MOCKING_ENABLED').then(() => {\r\n        if (!(options === null || options === void 0 ? void 0 : options.quiet)) {\r\n            console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');\r\n            console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\r\n            console.log('Found an issue? https://github.com/mswjs/msw/issues');\r\n            console.groupEnd();\r\n        }\r\n    });\r\n});\n\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\r\nconst createBroadcastChannel = (event) => {\r\n    const port = event.ports[0];\r\n    return {\r\n        /**\r\n         * Sends a text message to the connected Service Worker.\r\n         */\r\n        send(message) {\r\n            if (port) {\r\n                port.postMessage(message);\r\n            }\r\n        },\r\n    };\r\n};\n\nconst defaultContext = {\r\n    status,\r\n    set,\r\n    delay,\r\n    fetch,\r\n};\n\n/**\r\n * Composes a given list of functions into a new function that\r\n * executes from right to left.\r\n */\r\nfunction compose(...funcs) {\r\n    return funcs.reduce((f, g) => (...args) => f(g(...args)));\r\n}\n\nclass NetworkError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'NetworkError';\r\n    }\r\n}\n\nconst defaultResponse = {\r\n    status: 200,\r\n    statusText: 'OK',\r\n    body: null,\r\n    delay: 0,\r\n    once: false,\r\n};\r\nfunction createResponseComposition(overrides = {}) {\r\n    return (...transformers) => {\r\n        const resolvedResponse = Object.assign({}, defaultResponse, {\r\n            headers: new lib$1.Headers({\r\n                'x-powered-by': 'msw',\r\n            }),\r\n        }, overrides);\r\n        if (transformers.length > 0) {\r\n            return compose(...transformers)(resolvedResponse);\r\n        }\r\n        return resolvedResponse;\r\n    };\r\n}\r\nconst response = Object.assign(createResponseComposition(), {\r\n    once: createResponseComposition({ once: true }),\r\n    networkError(message) {\r\n        throw new NetworkError(message);\r\n    },\r\n});\n\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\r\nconst getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const relevantHandlers = handlers\r\n        .filter((requestHandler) => {\r\n        // Skip a handler if it has been already used for a one-time response.\r\n        return !requestHandler.shouldSkip;\r\n    })\r\n        .map((requestHandler) => {\r\n        // Parse the captured request to get additional information.\r\n        // Make the predicate function accept all the necessary information\r\n        // to decide on the interception.\r\n        const parsedRequest = requestHandler.parse\r\n            ? requestHandler.parse(req)\r\n            : null;\r\n        return [requestHandler, parsedRequest];\r\n    })\r\n        .filter(([requestHandler, parsedRequest]) => {\r\n        return requestHandler.predicate(req, parsedRequest);\r\n    });\r\n    if (relevantHandlers.length == 0) {\r\n        // Handle a scenario when a request has no relevant request handlers.\r\n        // In that case it would be bypassed (performed as-is).\r\n        return {\r\n            handler: null,\r\n            response: null,\r\n        };\r\n    }\r\n    const { requestHandler, parsedRequest, mockedResponse, publicRequest, } = yield relevantHandlers.reduce((asyncAcc, [requestHandler, parsedRequest]) => __awaiter(void 0, void 0, void 0, function* () {\r\n        // Now the reduce function is async so we need to await if response was found\r\n        const acc = yield asyncAcc;\r\n        // If a first not empty response was found we'll stop evaluating other requests\r\n        if (acc.requestHandler) {\r\n            return acc;\r\n        }\r\n        const { getPublicRequest, defineContext, resolver } = requestHandler;\r\n        const publicRequest = getPublicRequest\r\n            ? getPublicRequest(req, parsedRequest)\r\n            : req;\r\n        const context = defineContext\r\n            ? defineContext(publicRequest)\r\n            : defaultContext;\r\n        const mockedResponse = yield resolver(publicRequest, response, context);\r\n        if (!mockedResponse) {\r\n            return acc;\r\n        }\r\n        if (mockedResponse && mockedResponse.once) {\r\n            // When responded with a one-time response, match the relevant request handler\r\n            // as skipped, so it cannot affect the captured requests anymore.\r\n            requestHandler.shouldSkip = true;\r\n        }\r\n        return {\r\n            requestHandler,\r\n            parsedRequest,\r\n            mockedResponse,\r\n            publicRequest,\r\n        };\r\n    }), Promise.resolve({ mockedResponse: null }));\r\n    // Although reducing a list of relevant request handlers, it's possible\r\n    // that in the end there will be no handler associted with the request\r\n    // (i.e. if relevant handlers are fall-through).\r\n    if (!requestHandler) {\r\n        return {\r\n            handler: null,\r\n            response: null,\r\n        };\r\n    }\r\n    return {\r\n        handler: requestHandler,\r\n        response: mockedResponse,\r\n        publicRequest,\r\n        parsedRequest,\r\n    };\r\n});\n\nfunction onUnhandledRequest(request, onUnhandledRequest = 'bypass') {\r\n    if (typeof onUnhandledRequest === 'function') {\r\n        onUnhandledRequest(request);\r\n        return;\r\n    }\r\n    const publicUrl = getPublicUrlFromRequest(request);\r\n    const message = `captured a ${request.method} ${request.url} request without a corresponding request handler.\n\n  If you wish to intercept this request, consider creating a request handler for it:\n\n  rest.${request.method.toLowerCase()}('${publicUrl}', (req, res, ctx) => {\n    return res(ctx.text('body'))\n  })`;\r\n    switch (onUnhandledRequest) {\r\n        case 'error': {\r\n            throw new Error(`[MSW] Error: ${message}`);\r\n        }\r\n        case 'warn': {\r\n            console.warn(`[MSW] Warning: ${message}`);\r\n        }\r\n        default:\r\n            return;\r\n    }\r\n}\n\nfunction getAllCookies() {\r\n    return parse_1(document.cookie);\r\n}\r\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\r\nfunction getRequestCookies(req) {\r\n    switch (req.credentials) {\r\n        case 'same-origin': {\r\n            // Return document cookies only when requested a resource\r\n            // from the same origin as the current document.\r\n            return location.origin === req.url.origin ? getAllCookies() : {};\r\n        }\r\n        case 'include': {\r\n            // Return all document cookies.\r\n            return getAllCookies();\r\n        }\r\n        default: {\r\n            return {};\r\n        }\r\n    }\r\n}\n\nconst handleRequestWith = (context, options) => {\r\n    return (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n        const channel = createBroadcastChannel(event);\r\n        try {\r\n            const message = JSON.parse(event.data, function (key, value) {\r\n                if (key === 'url') {\r\n                    return new URL(value);\r\n                }\r\n                // Serialize headers\r\n                if (key === 'headers') {\r\n                    return new lib$1.Headers(value);\r\n                }\r\n                // Prevent empty fields from presering an empty value.\r\n                // It's invalid to perform a GET request with { body: \"\" }\r\n                if (\r\n                // Check if we are parsing deeper in `event.data.payload`,\r\n                // because this custom JSON parser is invoked for each depth level.\r\n                this.method &&\r\n                    isStringEqual(this.method, 'GET') &&\r\n                    key === 'body' &&\r\n                    value === '') {\r\n                    return undefined;\r\n                }\r\n                return value;\r\n            });\r\n            const { type, payload: req } = message;\r\n            // Ignore irrelevant worker message types\r\n            if (type !== 'REQUEST') {\r\n                return null;\r\n            }\r\n            // Parse the request's body based on the \"Content-Type\" header.\r\n            req.body = parseBody(req.body, req.headers);\r\n            // Set document cookies on the request.\r\n            req.cookies = getRequestCookies(req);\r\n            const { response, handler, publicRequest, parsedRequest, } = yield getResponse(req, context.requestHandlers);\r\n            // Handle a scenario when there is no request handler\r\n            // found for a given request.\r\n            if (!handler) {\r\n                onUnhandledRequest(req, options.onUnhandledRequest);\r\n                return channel.send({ type: 'MOCK_NOT_FOUND' });\r\n            }\r\n            // Handle a scenario when there is a request handler,\r\n            // but it doesn't return any mocked response.\r\n            if (!response) {\r\n                console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', response);\r\n                return channel.send({ type: 'MOCK_NOT_FOUND' });\r\n            }\r\n            const responseWithSerializedHeaders = Object.assign(Object.assign({}, response), { headers: lib$1.headersToList(response.headers) });\r\n            if (!options.quiet) {\r\n                setTimeout(() => {\r\n                    handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);\r\n                }, response.delay);\r\n            }\r\n            channel.send({\r\n                type: 'MOCK_SUCCESS',\r\n                payload: responseWithSerializedHeaders,\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (error instanceof NetworkError) {\r\n                // Treat emulated network error differently,\r\n                // as it is an intended exception in a request handler.\r\n                return channel.send({\r\n                    type: 'NETWORK_ERROR',\r\n                    payload: {\r\n                        name: error.name,\r\n                        message: error.message,\r\n                    },\r\n                });\r\n            }\r\n            // Treat all the other exceptions in a request handler\r\n            // as unintended, alerting that there is a problem needs fixing.\r\n            channel.send({\r\n                type: 'INTERNAL_ERROR',\r\n                payload: {\r\n                    status: 500,\r\n                    body: JSON.stringify({\r\n                        errorType: error.constructor.name,\r\n                        message: error.message,\r\n                        location: error.stack,\r\n                    }),\r\n                },\r\n            });\r\n        }\r\n    });\r\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // Signal Service Worker to report back its integrity\r\n        serviceWorker.postMessage('INTEGRITY_CHECK_REQUEST');\r\n        const { payload: actualChecksum } = yield context.events.once('INTEGRITY_CHECK_RESPONSE');\r\n        // Compare the response from the Service Worker and the\r\n        // global variable set by webpack upon build.\r\n        if (actualChecksum !== \"d1e0e502f550d40a34bee90822e4bf98\") {\r\n            throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"d1e0e502f550d40a34bee90822e4bf98\"}).`);\r\n        }\r\n        return serviceWorker;\r\n    });\r\n}\n\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\r\nfunction deferNetworkRequestsUntil(predicatePromise) {\r\n    // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\r\n    const originalXhrSend = window.XMLHttpRequest.prototype.send;\r\n    window.XMLHttpRequest.prototype.send = function (...args) {\r\n        // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\r\n        // because that method is always synchronous.\r\n        lib.until(() => predicatePromise).then(() => {\r\n            window.XMLHttpRequest.prototype.send = originalXhrSend;\r\n            this.send(...args);\r\n        });\r\n    };\r\n    // Defer any `fetch` requests until the Service Worker is ready.\r\n    const originalFetch = window.fetch;\r\n    window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {\r\n        yield lib.until(() => predicatePromise);\r\n        window.fetch = originalFetch;\r\n        return window.fetch(...args);\r\n    });\r\n}\n\nfunction isObject(obj) {\r\n    return typeof obj === 'object';\r\n}\r\n/**\r\n * Deeply merges two given objects with the right one\r\n * having a priority during property assignment.\r\n */\r\nfunction mergeRight(a, b) {\r\n    const result = Object.assign({}, a);\r\n    Object.entries(b).forEach(([key, value]) => {\r\n        const existingValue = result[key];\r\n        if (Array.isArray(existingValue) && Array.isArray(value)) {\r\n            result[key] = existingValue.concat(value);\r\n            return;\r\n        }\r\n        if (isObject(existingValue) && isObject(value)) {\r\n            result[key] = mergeRight(existingValue, value);\r\n            return;\r\n        }\r\n        result[key] = value;\r\n    });\r\n    return result;\r\n}\n\nconst DEFAULT_START_OPTIONS = {\r\n    serviceWorker: {\r\n        url: '/mockServiceWorker.js',\r\n        options: null,\r\n    },\r\n    quiet: false,\r\n    waitUntilReady: true,\r\n    onUnhandledRequest: 'bypass',\r\n    findWorker: (scriptURL, mockServiceWorkerUrl) => scriptURL === mockServiceWorkerUrl,\r\n};\r\nconst createStart = (context) => {\r\n    /**\r\n     * Registers and activates the mock Service Worker.\r\n     */\r\n    return function start(options) {\r\n        const resolvedOptions = mergeRight(DEFAULT_START_OPTIONS, options || {});\r\n        const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\r\n            if (!('serviceWorker' in navigator)) {\r\n                console.error(`[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).`);\r\n                return null;\r\n            }\r\n            // Remove all previously existing event listeners.\r\n            // This way none of the listeners persists between Fast refresh\r\n            // of the application's code.\r\n            context.events.removeAllListeners();\r\n            context.events.addListener(navigator.serviceWorker, 'message', handleRequestWith(context, resolvedOptions));\r\n            const [, instance] = yield lib.until(() => getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options, resolvedOptions.findWorker));\r\n            if (!instance) {\r\n                return null;\r\n            }\r\n            const [worker, registration] = instance;\r\n            if (!worker) {\r\n                if (options === null || options === void 0 ? void 0 : options.findWorker) {\r\n                    console.error(`\\\n[MSW] Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"${resolvedOptions.serviceWorker.url}\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`);\r\n                }\r\n                else {\r\n                    console.error(`\\\n[MSW] Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"${resolvedOptions.serviceWorker.url}\" cannot resolve against the actual public hostname (${location.host}). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`);\r\n                }\r\n                return null;\r\n            }\r\n            context.worker = worker;\r\n            context.registration = registration;\r\n            context.events.addListener(window, 'beforeunload', () => {\r\n                if (worker.state !== 'redundant') {\r\n                    // Notify the Service Worker that this client has closed.\r\n                    // Internally, it's similar to disabling the mocking, only\r\n                    // client close event has a handler that self-terminates\r\n                    // the Service Worker when there are no open clients.\r\n                    worker.postMessage('CLIENT_CLOSED');\r\n                }\r\n                // Make sure we're always clearing the interval - there are reports that not doing this can\r\n                // cause memory leaks in headless browser environments.\r\n                window.clearInterval(context.keepAliveInterval);\r\n            });\r\n            // Check if the active Service Worker is the latest published one\r\n            const [integrityError] = yield lib.until(() => requestIntegrityCheck(context, worker));\r\n            if (integrityError) {\r\n                console.error(`\\\n[MSW] Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\r\n            }\r\n            // Signal the Service Worker to enable requests interception\r\n            const [activationError] = yield lib.until(() => activateMocking(context, options));\r\n            if (activationError) {\r\n                console.error('Failed to enable mocking', activationError);\r\n                return null;\r\n            }\r\n            context.keepAliveInterval = window.setInterval(() => worker.postMessage('KEEPALIVE_REQUEST'), 5000);\r\n            return registration;\r\n        });\r\n        const workerRegistration = startWorkerInstance();\r\n        // Defer any network requests until the Service Worker instance is ready.\r\n        // This prevents a race condition between the Service Worker registration\r\n        // and application's runtime requests (i.e. requests on mount).\r\n        if (resolvedOptions.waitUntilReady) {\r\n            deferNetworkRequestsUntil(workerRegistration);\r\n        }\r\n        return workerRegistration;\r\n    };\r\n};\n\nconst createStop = (context) => {\r\n    /**\r\n     * Signal the Service Worker to disable mocking for this client.\r\n     * Use this an an explicit way to stop the mocking, while preserving\r\n     * the worker-client relation. Does not affect the worker's lifecycle.\r\n     */\r\n    return function stop() {\r\n        var _a;\r\n        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_DEACTIVATE');\r\n        context.events.removeAllListeners();\r\n        window.clearInterval(context.keepAliveInterval);\r\n    };\r\n};\n\nfunction use(currentHandlers, ...handlers) {\r\n    currentHandlers.unshift(...handlers);\r\n}\r\nfunction restoreHandlers(handlers) {\r\n    handlers.forEach((handler) => {\r\n        if ('shouldSkip' in handler) {\r\n            handler.shouldSkip = false;\r\n        }\r\n    });\r\n}\r\nfunction resetHandlers(initialHandlers, ...nextHandlers) {\r\n    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\r\n}\n\n// Declare the list of event handlers on the module's scope\r\n// so it persists between Fash refreshes of the application's code.\r\nlet listeners = [];\r\nfunction setupWorker(...requestHandlers) {\r\n    requestHandlers.forEach((handler) => {\r\n        if (Array.isArray(handler))\r\n            throw new Error(`[MSW] Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).`);\r\n    });\r\n    const context = {\r\n        worker: null,\r\n        registration: null,\r\n        requestHandlers: [...requestHandlers],\r\n        events: {\r\n            addListener(target, event, callback) {\r\n                target.addEventListener(event, callback);\r\n                listeners.push({ event, target, callback });\r\n                return () => {\r\n                    target.removeEventListener(event, callback);\r\n                };\r\n            },\r\n            removeAllListeners() {\r\n                for (const { target, event, callback } of listeners) {\r\n                    target.removeEventListener(event, callback);\r\n                }\r\n                listeners = [];\r\n            },\r\n            once(type) {\r\n                const bindings = [];\r\n                return new Promise((resolve, reject) => {\r\n                    const handleIncomingMessage = (event) => {\r\n                        try {\r\n                            const message = JSON.parse(event.data);\r\n                            if (message.type === type) {\r\n                                resolve(message);\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            reject(error);\r\n                        }\r\n                    };\r\n                    bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\r\n                }).finally(() => {\r\n                    bindings.forEach((unbind) => unbind());\r\n                });\r\n            },\r\n        },\r\n    };\r\n    // Error when attempting to run this function in a NodeJS environment.\r\n    if (isNodeProcess()) {\r\n        throw new Error('[MSW] Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for NodeJS environment instead.');\r\n    }\r\n    return {\r\n        start: createStart(context),\r\n        stop: createStop(context),\r\n        use(...handlers) {\r\n            use(context.requestHandlers, ...handlers);\r\n        },\r\n        restoreHandlers() {\r\n            restoreHandlers(context.requestHandlers);\r\n        },\r\n        resetHandlers(...nextHandlers) {\r\n            context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\r\n        },\r\n    };\r\n}\n\nexport { defaultContext, response, setupWorker };\n"]},"metadata":{},"sourceType":"module"}